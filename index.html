<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Latest</title>
  <!-- ADDED BY AI START -->
  <link rel="stylesheet" href="https://use.typekit.net/cdf4adh.css">
  <!-- ADDED BY AI END -->
  <script>
    /* ADDED BY AI START */
    // Always start at the top on refresh / page load (disable scroll restoration).
    // Handles normal reloads + bfcache restores (Safari/Chrome back-forward cache).
    if ("scrollRestoration" in history) {
      history.scrollRestoration = "manual";
    }

    const scrollToTop = () => {
      window.scrollTo(0, 0);
      // Some browsers apply scroll restoration after load; do a couple extra ticks.
      requestAnimationFrame(() => window.scrollTo(0, 0));
      setTimeout(() => window.scrollTo(0, 0), 0);
    };

    window.addEventListener("DOMContentLoaded", scrollToTop, { once: true });
    window.addEventListener("pageshow", scrollToTop);
    /* ADDED BY AI END */
  </script>
</head>
<style>
  :root {
    --revolver-angle: 30deg;
    /* Revolver rotation range over a full page scroll (increase magnitude = faster spin) */
    --revolver-rotation-range: -360deg;
    --white: #F9F4F1;
    --black: #333333;
    --futura-cond: "Futura Cond", system-ui, -apple-system, "Segoe UI", Roboto, Arial, sans-serif;

    --moret-variable: "moret-variable", serif;
  }

  /* Futura Cond from futura-cond_uEZPE.zip */
  @font-face {
    font-family: "Futura Cond";
    src: url("./assets/fonts/FuturaCond-Medium.otf") format("opentype");
    font-weight: 500;
    font-style: normal;
    font-display: swap;
  }

  @font-face {
    font-family: "Futura Cond";
    src: url("./assets/fonts/FuturaCond-MediumItalic.otf") format("opentype");
    font-weight: 500;
    font-style: italic;
    font-display: swap;
  }

  @font-face {
    font-family: "Futura Cond";
    src: url("./assets/fonts/FuturaCond-Bold.otf") format("opentype");
    font-weight: 700;
    font-style: normal;
    font-display: swap;
  }

  @font-face {
    font-family: "Futura Cond";
    src: url("./assets/fonts/FuturaCond-BoldItalic.otf") format("opentype");
    font-weight: 700;
    font-style: italic;
    font-display: swap;
  }


  html {
    width: 100%;
    height: 100%;
    box-sizing: border-box;
    overflow-x: clip;
    scrollbar-gutter: stable;
  }

  body {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
    background-color: var(--white);
    overflow-x: clip;
    font-family: "Futura Cond", system-ui, -apple-system, "Segoe UI", Roboto, Arial, sans-serif;
    transition: overflow 0.3s ease-in-out;
  }

  a {
    text-decoration: none;
    color: inherit;
    cursor: pointer;
    font-family: var(--futura-cond);
  }
  .custom-button {
    padding-block: .417vw;
    padding-inline: .764vw;
    border: .069vw solid #333;
    background:  #FF944D;
    border-radius: 1.736vw;
    font-size: .833vw;;
    font-weight: 600;
    line-height: 1;
    letter-spacing: -0.025vw;
    text-transform: uppercase;
  }

  h1,
  h2,
  h3,
  h4,
  h5,
  h6 {
    margin: 0;
  }

  /* ADDED BY AI START */
  /* Locks scrolling while the preloader runs */
  body.is-loading {
    overflow: hidden;
    height: 100vh;
    padding-right: var(--sbw, 0vw);
  }

  /* ADDED BY AI END */

  * {
    box-sizing: border-box;
  }

  .h1 {
    font-family: var(--moret-variable);
    font-size: 20.021vw;
    font-weight: 300;
    line-height: 0.8;
    letter-spacing: -1.001vw;
    text-transform: uppercase;
    margin: 0;
    color: var(--black);
  }


  .h2 {
    font-size: 4.861vw;
    font-weight: 700;
    line-height: 0.85;
    letter-spacing: -0.243vw;
    text-transform: uppercase;
    color: white;
  }



  .h4 {
    font-size: 2.778vw;
    line-height: 0.85;
    font-weight: 700;
    text-transform: uppercase;
    letter-spacing: -0.139vw;
  }

  img {
    display: block;
    width: 100%;
    height: 100%;
    object-fit: cover;
  }

  .triple-line {
    width: 100%;
    height: 100%;
    position: relative;

    &::before {
      content: '';
      position: absolute;
      top: 0;
      left: 50%;
      transform: translateX(-50%);
      width: 50vw;
      height: 100%;
      background: url('./assets/tripleline.png') no-repeat center center;
    }
  }

  .revolver-parent {
    width: 100%;
    min-height: 91.736vw;
    position: relative;
    background-color: #333;
    overflow-x: clip;

    & .right-text {
      max-width: 9.792vw;
      position: absolute;
      right: 14.653vw;
      top: 48.056vw;
      z-index: 5;

      & h5 {
        text-transform: uppercase;
        
      }
    }

    & .squiggly-gif-2 {
      position: absolute;
      top: 38.958vw;
      left: 9.444vw;
      width: 21.52vw;
      height: 21.52vw;
      z-index: 4;
    }

    & .middle-text {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      text-align: center;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 1.042vw;
      text-wrap: nowrap;

      & .dollar-icon {
        width: 1em;
        height: 1em;
        display: inline-block;
        margin-inline: 0.3em;
    }
  }

}

.dark {
  color: white;
}

  /* outer wrapper: stays centered, never rotates */
  .revolver-center {
    position: absolute;
    top: 4.375vw;
    left: 50%;
    transform: translate3d(-50%, 0, 0);
    width: 60.944vw;
    aspect-ratio: 1/1;

  }

  /* inner wrapper: rotates in-place */
  .revolver-wrapper {
    width: 100%;
    height: 100%;
    transform: rotate(calc(var(--progress, 0) * var(--revolver-rotation-range)));
    transform-origin: 50% 50%;
    will-change: transform;
  }

  .revolver-item {
    width: 10.126vw;
    height: 100%;
    position: absolute;
    top: 0;
    left: 50%;
    transform: translate3d(-50%, 0, 0) rotate(calc(var(--revolver-angle) * var(--revolver-index)));
  }

  /* plain CSS (the `& img {}` nesting only works in SCSS) */
  .revolver-item img {
    height: unset;
    width: 100%;
  }


  .grain-effect {
    position: relative;
    width: 100%;
    height: 100%;
    min-width: 100%;
    overflow: hidden;
    isolation: isolate;
  }

  .grain-effect::after {
    content: '';
    position: absolute;
    top: -5%;
    left: -5%;
    ;
    width: 110%;
    height: 110%;
    opacity: .35;
    background-image: repeating-conic-gradient(var(--black) 0%, transparent .00003%, transparent .0005%, transparent .00095%), repeating-conic-gradient(var(--black) 0%, transparent .00005%, transparent 0.00015%, transparent 0.0009%);
    background-size: cover;
    animation: grain 0.5s steps(1) infinite;
    z-index: 0;
    pointer-events: none;
    transform: scale(2);
    /* try 1.5 → 3 */
    transform-origin: center;
  }

  .triple-line::before {
    z-index: 1;
    /* above grain, below content */
    pointer-events: none;
  }

  /* lift only the section’s immediate content */
  .grain-effect>* {
    position: relative;
    z-index: 2;
  }





  @keyframes grain {

    0%,
    100% {
      transform: translate(0, 0);
    }

    10% {
      transform: translate(-1%, -1%);
    }

    20% {
      transform: translate(1%, 1%);
    }

    30% {
      transform: translate(-2%, -2%);
    }

    40% {
      transform: translate(3%, 3%);
    }

    50% {
      transform: translate(-3%, -3%);
    }

    60% {
      transform: translate(4%, 4%);
    }

    70% {
      transform: translate(-4%, -4%);
    }

    80% {
      transform: translate(2%, 2%);
    }

    90% {
      transform: translate(-3%, -3%);
    }
  }



  .preloader-to-banner {
    width: 100%;
    min-height: 100vh;
    height: 72.986vw;
    /* ADDED BY AI START */
    /* Full-screen overlay so user cannot scroll to content underneath */
    /* position: fixed;
    inset: 0;
    z-index: 9999; */
    /* If you keep it non-fixed for now, we still need it positioned so the progress bar can sit at the bottom */
    position: relative;
    /* ADDED BY AI END */
    background-color: var(--white);

    & .wrapper {
      width: 100%;
      height: 100%;

      & .preloader {
        width: 100%;
        height: 100%;
        display: flex;
        justify-content: center;
        flex-direction: column;
        align-items: center;
        gap: 1.042vw;
        padding-top: 7.111vw;

        & .gif-effect {
          position: absolute;
          top: 6.944vw;
          left: 44.097vw;
          width: 12.995vw;
          height: 19.779vw;
          will-change: transform;
          transform: translateZ(0);

          & img {
            position: absolute;
            width: 100%;
            height: 100%;
            object-fit: cover;
            opacity: 0;
          }
        }


        & .opening-header {
          max-width: 23.486vw;
          position: absolute;
          top: 30vw;
          max-width: 23.486vw;

          & h4 {
            text-align: center;
          }
        }
      }


    }
  }

  /* "gif" frame state (used by JS) */
  .gif-effect img.is-active {
    opacity: 1 !important;
  }

  /* ADDED BY AI START */
  /*
    IMPORTANT:
    You currently have SCSS-style nesting in this file (selectors using `&`).
    Browsers ignore that in a normal <style> tag, which can cause .gif-effect to have no sizing,
    and images to end up invisible (height: 100% of an auto/0-height parent).

    These are plain-CSS overrides to ensure the preloader + gif frames always render.
  */
  .preloader-to-banner>.wrapper {
    width: 100%;
    height: 100%;
    position: relative;
  }

  .preloader-to-banner .abso-content {
    width: 100%;
    height: 100%;
    position: relative;
    overflow: clip;
    z-index: 3;

    &>* {
      position: absolute;
      z-index: 3;
    }

    & .top-texts {
      display: flex;
      gap: 20.833vw;
      left: 0.694vw;
      top: 27.361vw;

    }

    & .middle-text {
      max-width: 6.806vw;
      left: 6.042vw;
      bottom: 17.014vw;
    }

    & #guy {
      width: 18.965vw;
      height: 41.806vw;
      bottom: -17.847vw;
      left: 12.917vw;
    }

    & #top-left {
      width: 36.736vw;
      height: 24.167vw;
      top: 29.361vw;
      left: -3.958vw;
    }

    & #topright {
      height: 31.582vw;
      top: 24.361vw;
      right: -10.417vw;
    }

    & #bottom-right {
      width: 33.666vw;
      height: 26.228vw;
      bottom: -10.903vw;
      right: -5.694vw;
    }

    & .squiggly-gif-container {
      width: 13.264vw;
      height: 15.972vw;
      top: 24.833vw;
      right: 29.583vw;

    }



  }

  /* ADDED BY AI START */
  /* Abso-content reveal (mask up for text, blur+fade+up for squiggly) */
  .preloader-to-banner .abso-content .top-texts,
  .preloader-to-banner .abso-content .middle-text,
  .preloader-to-banner .abso-content .squiggly-gif-container,
  .preloader-to-banner .abso-content #guy,
  .preloader-to-banner .abso-content #top-left,
  .preloader-to-banner .abso-content #topright,
  .preloader-to-banner .abso-content #bottom-right {
    visibility: hidden;
    /* prevent flash before GSAP runs */
  }

  .preloader-to-banner .abso-content .top-texts h6,
  .preloader-to-banner .abso-content .middle-text h6 {
    overflow: hidden;
    /* mask floor */
  }

  .preloader-to-banner .abso-content .abso-line {
    display: block;
    will-change: transform;
  }

  .preloader-to-banner .abso-content #guy,
  .preloader-to-banner .abso-content #top-left,
  .preloader-to-banner .abso-content #topright,
  .preloader-to-banner .abso-content #bottom-right {
    will-change: transform;
  }

  /* ADDED BY AI END */

  .preloader-to-banner .preloader {
    width: 100%;
    height: 100%;
    min-height: 100vh;
    display: flex;
    justify-content: center;
    flex-direction: column;
    align-items: center;
    gap: 1.042vw;
    padding-top: 7.111vw;
    overflow-y: clip;
  }


  .preloader-to-banner .gif-effect img {
    position: absolute;
    inset: 0;
    width: 100%;
    height: 100%;
    object-fit: cover;
    opacity: 0;

  }

  .progress {
    position: absolute;
    top: 45.083vw;
    left: 50%;
    transform: translateX(-50%);
  }

  .preloader-to-banner .gif-effect img.is-active {
    opacity: 1;
  }

  /* ADDED BY AI START */
  /* Generic mask helper for text reveal/hide animations */
  .mask {
    overflow: hidden;
    overflow-x: visible !important;
  }

  /* Ensure masked text animates cleanly */
  .mask>* {
    display: block;
    will-change: transform;
  }

  /* Line-by-line masking (each line gets its own overflow-hidden wrapper) */
  .mask .line-mask {
    overflow: hidden;
    overflow-x: visible !important;
  }

  .mask .line {
    display: block;
    will-change: transform;
  }

  /* ADDED BY AI END */

  .hero-banner {
    width: 100%;
    height: 100%;

    & .wrapper {
      width: 100%;
      height: 100%;


      & .top {
        position: absolute;
        top: 4.583vw;
        left: 0.694vw;
      }
    }
  }

  /* ADDED BY AI START */
  /*
    Plain-CSS override for hero banner (your `&` nesting above is SCSS syntax and won't apply in a normal <style> tag).
    This ensures the banner headline positioning works.
  */
  .preloader-to-banner .hero-banner {
    width: 100%;
    height: 100%;
    position: absolute;
    inset: 0;
  }

  .preloader-to-banner .hero-banner .wrapper {
    width: 100%;
    height: 100%;
    position: relative;
  }

  .preloader-to-banner .hero-banner .top {
    position: absolute;
    top: 4.2vw;
    left: 11.269vw;
    overflow-x: visible;
  }

  .preloader-to-banner .hero-banner .bottom {
    & .opening-video {
      width: 97.917vw;
      height: 45.833vw;
      margin-inline: auto;
      transform: translateY(110%);
      background: transparent;
      line-height: 0;
      font-size: 0;
      display: block;
      will-change: transform, height, width;
      transform: translateZ(0);
    }
  }

  video {
    display: block;
    width: 97.917vw;
    height: 45.833vw;
    object-fit: cover;
    will-change: transform;
    transform: translateZ(0);

  }

  /* ADDED BY AI END */

  /* ADDED BY AI START */
  /*
    Ensure the opening video is actually visible/positioned.
    The rule above uses nested selectors; modern browsers may support it, but GSAP can "inherit" the transform
    and turn it into extra translateY pixels (causing the video to stay off-screen).

    These overrides:
    - pin the bottom area
    - apply sizing with a plain selector
    - avoid a CSS transform so GSAP fully controls the Y movement
  */
  .preloader-to-banner .hero-banner .bottom {
    position: absolute;
    left: 0;
    right: 0;
    bottom: 0;
    pointer-events: none;
  }

  .preloader-to-banner .hero-banner .bottom .opening-video {
    width: 97.917vw;
    height: 45.833vw;
    margin-inline: auto;
    pointer-events: auto;
    transform: none;
    overflow: hidden;
    border-radius: 0;
    will-change: width, height, border-radius;
    position: relative;
  }

  /* ADDED BY AI START */
  /* Plain CSS for the video-text overlay (your nested `&` version may not apply depending on browser) */
  .preloader-to-banner .hero-banner .bottom .opening-video .video-text {
    position: absolute;
    top: 6.875vw;
    left: 50%;
    transform: translateX(-50%);
    z-index: 3;
    will-change: transform;
    display: flex;
    flex-direction: column;
  }

  /* ADDED BY AI START */
  /* Hidden by default; revealed via GSAP after globe animation */
  .preloader-to-banner .hero-banner .bottom .opening-video .video-text.video-text-next {
    visibility: hidden;
  }

  /* ADDED BY AI END */

  /* ADDED BY AI START */
  /* Final message (H2) overlay */
  .preloader-to-banner .hero-banner .bottom .opening-video .video-text-final {
    position: absolute;
    top: 6.875vw;
    left: 50%;
    transform: translateX(-50%);
    z-index: 4;
    visibility: hidden;
    text-align: center;
  }

  .preloader-to-banner .hero-banner .bottom .opening-video .video-text-final .line-mask {
    display: block;
    overflow: hidden;
  }

  .preloader-to-banner .hero-banner .bottom .opening-video .video-text-final .line {
    display: block;
    will-change: transform;
  }

  /* ADDED BY AI END */

  .preloader-to-banner .hero-banner .bottom .opening-video .video-text .video-text-pill {
    position: relative;
    display: inline-block;
    overflow: hidden;
    /* mask "floor" */
  }

  .preloader-to-banner .hero-banner .bottom .opening-video .video-text .video-text-inner {
    position: relative;
    will-change: transform;
  }

  .preloader-to-banner .hero-banner .bottom .opening-video .video-text .video-text-bg {
    position: absolute;
    inset: 0;
    background: var(--white);
    z-index: 0;
  }

  .preloader-to-banner .hero-banner .bottom .opening-video .video-text .video-text-text {
    position: relative;
    z-index: 1;
    text-align: center;
    color: var(--black);
  }

  .preloader-to-banner .hero-banner .bottom .opening-video .video-text img {
    width: 1em;
    height: 1em;
    object-fit: cover;
    display: inline-block;
    vertical-align: -0.1em;
  }

  /* ADDED BY AI END */

  /* ADDED BY AI START */
  /* Globe overlay styling */
  .preloader-to-banner .hero-banner .bottom .opening-video .globe {
    position: absolute;
    left: 50%;
    top: 0;
    transform: translate(-50%, 0);
    width: 48.958vw;
    height: 25.556vw;
    z-index: 2;
    pointer-events: none;
    visibility: hidden;
    will-change: transform;
  }

  /* ADDED BY AI END */

  .video-text {
    position: absolute;
    top: 6.875vw;
    left: 50%;
    transform: translateX(-50%);
    z-index: 3;

    & h4 {
      text-align: center;
      background: #F9F4F1;
      padding: 0.556vw;

      & img {
        width: 1em;
        height: 1em;
        object-fit: cover;
        display: inline-block;
      }
    }
  }
</style>

<body>
  <section class="preloader-to-banner grain-effect triple-line">
    <div class="wrapper">
      <div class="preloader">
        <div class="gif-effect">
          <img id="to-banner" src="./assets/h-1.png" alt="">
          <img src="./assets/h-2.png" alt="">
          <img src="./assets/h-3.png" alt="">
        </div>

        <div class="opening-header">
          <!-- ADDED BY AI START -->
          <!-- Mask wrapper for "slide down/out" animation -->
          <div class="mask">
            <h4 class="h4">
              To be human is to be <br> a part of something <br> bigger
            </h4>
          </div>
          <!-- ADDED BY AI END -->
        </div>

        <div class="progress">
          <!-- ADDED BY AI START -->
          <!-- Mask wrapper for "slide down/out" animation -->
          <div class="mask">
            <h6>0%</h6>
          </div>
          <!-- ADDED BY AI END -->
        </div>
      </div>

      <div class="hero-banner">
        <div class="wrapper">
          <div class="top">
            <!-- ADDED BY AI START -->
            <!-- Mask wrapper for "reveal from floor" animation -->
            <div class="mask hero-title-mask">
              <h1 class="h1 moret">UMAN-I-TEES</h1>
            </div>
            <!-- ADDED BY AI END -->
          </div>

          <div class="bottom">
            <div class="opening-video">
              <div class="video-text">
                <!-- ADDED BY AI START -->
                <!-- Video-text: TWO pills (one per <br> line). Each pill masks its own inner content "down into the floor". -->
                <div class="video-text-pill">
                  <div class="video-text-inner">
                    <div class="video-text-bg" aria-hidden="true"></div>
                    <div class="video-text-text">
                      <h4 class="h4">HUMANS DON'T CHANGE</h4>
                    </div>
                  </div>
                </div>

                <div class="video-text-pill">
                  <div class="video-text-inner">
                    <div class="video-text-bg" aria-hidden="true"></div>
                    <div class="video-text-text">
                      <h4 class="h4">THE WORLD <img src="./assets/video-text-icon.png" alt=""> ALONE</h4>
                    </div>
                  </div>
                </div>
                <!-- ADDED BY AI END -->
              </div>

              <!-- ADDED BY AI START -->
              <!-- Second message: reveal after globe slides up -->
              <div class="video-text video-text-next" aria-hidden="true">
                <div class="video-text-pill">
                  <div class="video-text-inner">
                    <div class="video-text-bg" aria-hidden="true"></div>
                    <div class="video-text-text">
                      <h4 class="h4">WE CHANGE IT</h4>
                    </div>
                  </div>
                </div>

                <div class="video-text-pill">
                  <div class="video-text-inner">
                    <div class="video-text-bg" aria-hidden="true"></div>
                    <div class="video-text-text">
                      <h4 class="h4">TOGETHER</h4>
                    </div>
                  </div>
                </div>
              </div>
              <!-- ADDED BY AI END -->

              <!-- ADDED BY AI START -->
              <!-- Third message: reveal after "WE CHANGE IT / TOGETHER" -->
              <div class="video-text-final" aria-hidden="true">
                <h2 class="h2">
                  <span class="line-mask"><span class="line">One story, one choice</span></span>
                  <span class="line-mask"><span class="line">at a time.</span></span>
                </h2>
              </div>
              <!-- ADDED BY AI END -->
              <video src="./assets/banner-video.mp4" autoplay muted loop playsinline preload="auto"></video>
              <!-- ADDED BY AI START -->
              <!-- Globe overlay (animated in during the pinned scroll) -->
              <img class="globe" src="./assets/globe.png" alt="" aria-hidden="true">
              <!-- ADDED BY AI END -->
            </div>
          </div>


          <div class="abso-content">
            <div class="top-texts">
              <h6><span class="abso-line">VOLUME 01</span></h6>
              <h6><span class="abso-line">THE BEGINNING OF SOMETHING BIGGER</span></h6>
            </div>

            <div class="squiggly-gif-container">
              <img src="./assets/Wear_What_Matters_Black.gif" alt="">
            </div>

            <div class="middle-text">
              <h6><span class="abso-line">In a world of noise, the most powerful voice is one that stands for
                  others.</span></h6>
            </div>

            <div id="top-left">
              <img src="./assets/top-left.png" alt="">
            </div>

            <div id="guy">
              <img src="./assets/guy.png" alt="">
            </div>

            <div id="topright">
              <img src="./assets/top-right.png" alt="">
            </div>

            <div id="bottom-right">
              <img src="./assets/bottom-right.png" alt="">
            </div>


          </div>
        </div>
      </div>
    </div>


  </section>


  <div class="revolver-parent triple-line grain-effect">

    <div class="squiggly-gif-2">
      <img src="./assets/Stand together.gif" alt="">
    </div>

    <div class="right-text">
      <h5 class="h5 dark">HUMANITEES, The name is a mashup of “Humanity” and “Tees.” It’s about connecting people through clothing and standing for something bigger than ourselves.</h5>
    </div>

    <div class="revolver-center">

      <div class="middle-text">
        <h5 class="h5 subhead dark">STARTED BACK IN THE 90S</h5>
        <h4 class="h4 dark">WE MAKE CLOTHING THAT SPARKS <br> CONVERSATION AND DRIVE ACTION, <br> DONATING 1 <img class="dollar-icon"
            src="./assets/dollar-icon.png" alt=""> FROM EVERY SHIRT <br> TO OUR PLANET.</h4>

            <a href="#" class="custom-button">About</a>
      </div>

      <div class="revolver-wrapper">
        <div style="--revolver-index: 0;" class="revolver-item">
          <img src="./assets/Group 54.png" alt="" />
        </div>
        <div style="--revolver-index: 1;" class="revolver-item">
          <img src="./assets/Group 54.png" alt="" />
        </div>
        <div style="--revolver-index: 2;" class="revolver-item">
          <img src="./assets/Group 54.png" alt="" />
        </div>
        <div style="--revolver-index: 3;" class="revolver-item">
          <img src="./assets/Group 54.png" alt="" />
        </div>
        <div style="--revolver-index: 4;" class="revolver-item">
          <img src="./assets/Group 54.png" alt="" />
        </div>
        <div style="--revolver-index: 5;" class="revolver-item">
          <img src="./assets/Group 54.png" alt="" />
        </div>
        <div style="--revolver-index: 6;" class="revolver-item">
          <img src="./assets/Group 54.png" alt="" />
        </div>
        <div style="--revolver-index: 7;" class="revolver-item">
          <img src="./assets/Group 54.png" alt="" />
        </div>
        <div style="--revolver-index: 8;" class="revolver-item">
          <img src="./assets/Group 54.png" alt="" />
        </div>
        <div style="--revolver-index: 9;" class="revolver-item">
          <img src="./assets/Group 54.png" alt="" />
        </div>
        <div style="--revolver-index: 10;" class="revolver-item">
          <img src="./assets/Group 54.png" alt="" />
        </div>
        <div style="--revolver-index: 11;" class="revolver-item">
          <img src="./assets/Group 54.png" alt="" />
        </div>
      </div>
    </div>
  </div>

  <!-- Lenis + GSAP -->
  <!-- Lenis (CDN fallback: jsDelivr -> unpkg) -->
  <script src="https://cdn.jsdelivr.net/npm/lenis@1.3.4/dist/lenis.min.js"
    onerror="this.onerror=null;this.src='https://unpkg.com/lenis@1.3.4/dist/lenis.min.js';"></script>
  <script src="https://cdn.jsdelivr.net/npm/gsap@3.12.5/dist/gsap.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/gsap@3.12.5/dist/ScrollTrigger.min.js"></script>
  <script>

    (function () {

      function onReady(fn) {
        if (window.jQuery) {
          jQuery(fn);
          return;
        }
        if (document.readyState === "loading")
          document.addEventListener("DOMContentLoaded", fn, { once: true });
        else fn();
      }

      onReady(function () {
        /* ADDED BY AI START */
        // Split text inside an element (e.g. H1/H4) into real rendered lines so we can animate line-by-line.
        // IMPORTANT: we keep the original element so your existing typography/styles still apply.
        // No plugins required (avoids GSAP SplitText).
        function splitTextElToLines(textEl) {
          if (!textEl) return [];

          // If already split, reuse existing lines 
          const existing = Array.from(textEl.querySelectorAll(".line"));
          if (existing.length) return existing;

          // If author added <br> tags, treat them as HARD line breaks and follow them exactly.
          // This avoids reflow-based line detection and preserves your intended line structure.
          const hasBr = !!textEl.querySelector("br");
          if (hasBr) {
            const clone = textEl.cloneNode(true);
            clone.querySelectorAll("br").forEach((br) => br.replaceWith(document.createTextNode("\n")));
            const parts = (clone.textContent || "")
              .split("\n")
              .map((s) => s.trim())
              .filter(Boolean);

            const frag = document.createDocumentFragment();
            const lineEls = [];

            parts.forEach((part) => {
              const lineMask = document.createElement("span");
              lineMask.className = "line-mask";
              lineMask.style.display = "block";
              lineMask.style.overflow = "hidden";

              const line = document.createElement("span");
              line.className = "line";
              line.style.display = "block";

              const words = part.split(/\s+/).filter(Boolean);
              words.forEach((w, idx) => {
                const word = document.createElement("span");
                word.style.display = "inline-block";
                word.textContent = w;
                line.appendChild(word);
                if (idx !== words.length - 1) {
                  line.appendChild(document.createTextNode(" "));
                }
              });

              lineMask.appendChild(line);
              frag.appendChild(lineMask);
              lineEls.push(line);
            });

            textEl.innerHTML = "";
            textEl.appendChild(frag);
            return lineEls;
          }

          const text = (textEl.textContent || "").trim();
          if (!text) return [];

          // Turn the text into word spans so we can measure line breaks
          const words = text.split(/\s+/);
          textEl.textContent = "";

          const wordSpans = words.map((w) => {
            const span = document.createElement("span");
            span.style.display = "inline-block";
            span.textContent = w;
            textEl.appendChild(span);
            // IMPORTANT: use a real text node space between inline-block spans
            // (trailing spaces inside spans can get collapsed and "disappear")
            textEl.appendChild(document.createTextNode(" "));
            return span;
          });
          // Remove the last trailing space node we added
          if (textEl.lastChild && textEl.lastChild.nodeType === Node.TEXT_NODE) {
            textEl.removeChild(textEl.lastChild);
          }

          // Group words by offsetTop (each unique top == a new line)
          const lines = [];
          let currentTop = null;
          let currentLine = [];

          wordSpans.forEach((span) => {
            const top = span.offsetTop;
            if (currentTop === null) currentTop = top;
            if (top !== currentTop) {
              lines.push(currentLine);
              currentLine = [];
              currentTop = top;
            }
            currentLine.push(span);
          });
          if (currentLine.length) lines.push(currentLine);

          // Replace element contents with inline wrappers (valid inside H1/H4/H6)
          const frag = document.createDocumentFragment();
          const lineEls = [];

          lines.forEach((lineWords) => {
            const lineMask = document.createElement("span");
            lineMask.className = "line-mask";
            lineMask.style.display = "block";
            lineMask.style.overflow = "hidden";

            const line = document.createElement("span");
            line.className = "line";
            line.style.display = "block";

            // Rebuild spans + spaces so spacing is guaranteed
            lineWords.forEach((wSpan, idx) => {
              const clone = wSpan.cloneNode(true);
              line.appendChild(clone);
              // Add a space after every word except the last word in the entire text
              // (trailing spaces at end of a block line won't show, so this is safe).
              const isLastWordOverall = wSpan === wordSpans[wordSpans.length - 1];
              if (!isLastWordOverall) {
                line.appendChild(document.createTextNode(" "));
              }
            });
            lineMask.appendChild(line);
            frag.appendChild(lineMask);
            lineEls.push(line);
          });

          textEl.innerHTML = "";
          textEl.appendChild(frag);

          return lineEls;
        }

        // Wrap <br>-separated lines without destroying inline elements (e.g. <img> inside a headline).
        // Returns the created `.line` elements (each inside a `.line-mask`).
        function wrapBrSeparatedLinesToMasks(textEl) {
          if (!textEl) return [];
          const existing = Array.from(textEl.querySelectorAll(":scope > .line-mask > .line"));
          if (existing.length) return existing;

          const children = Array.from(textEl.childNodes);
          const lines = [];
          let buf = [];

          const flush = () => {
            // Keep empty lines out
            if (!buf.length) return;
            lines.push(buf);
            buf = [];
          };

          children.forEach((node) => {
            if (node.nodeType === Node.ELEMENT_NODE && node.nodeName === "BR") {
              flush();
            } else {
              buf.push(node);
            }
          });
          flush();

          const frag = document.createDocumentFragment();
          const lineEls = [];
          lines.forEach((nodes) => {
            const lineMask = document.createElement("span");
            lineMask.className = "line-mask";
            lineMask.style.display = "block";
            lineMask.style.overflow = "hidden";

            const line = document.createElement("span");
            line.className = "line";
            line.style.display = "block";
            line.style.willChange = "transform";

            nodes.forEach((n) => line.appendChild(n));
            lineMask.appendChild(line);
            frag.appendChild(lineMask);
            lineEls.push(line);
          });

          textEl.innerHTML = "";
          textEl.appendChild(frag);
          return lineEls;
        }

        // Smooth preloader timeline:
        // - locks scroll
        // - cycles images like a "gif"
        // - counts 0% -> 100% over ~2.5s (not tied to real load)
        // - at 100%, forces the FIRST image to show and pauses there
        // - fades the preloader out and unlocks scroll
        //
        // Then we initialize Lenis AFTER the preloader, so nothing scroll-driven runs underneath.
        function runPreloader() {
          return new Promise((resolve) => {
            const preloaderSection = document.querySelector(".preloader-to-banner");
            const frames = Array.from(document.querySelectorAll(".gif-effect img"));
            const progressEl = document.querySelector(".preloader .progress h6");
            const gifEffectEl = document.querySelector(".gif-effect");
            const openingHeaderEl = document.querySelector(".opening-header .mask .h4");
            const progressText = document.querySelector(".progress .mask > *");
            const heroTitleEl = document.querySelector(".hero-banner .hero-title-mask .h1");
            const openingVideoEl = document.querySelector(".opening-video");
            const videoTextEl = document.querySelector(".opening-video .video-text");
            const videoTextInners = videoTextEl
              ? Array.from(videoTextEl.querySelectorAll(".video-text-inner"))
              : [];
            // before adding is-loading
            const sbw = window.innerWidth - document.documentElement.clientWidth;
            document.documentElement.style.setProperty("--sbw", sbw + "px");
            document.body.classList.add("is-loading");

            // when unlocking
            document.body.classList.remove("is-loading");
            document.documentElement.style.removeProperty("--sbw");

            if (!preloaderSection || frames.length === 0 || !progressEl) {
              resolve();
              return;
            }

            document.body.classList.add("is-loading");

            const setActiveFrame = (idx) => {
              frames.forEach((img, i) => img.classList.toggle("is-active", i === idx));
            };

            // Initial state
            setActiveFrame(0);
            progressEl.textContent = "0%";
            // Prepare line-by-line masks and initial hero hidden state
            const openingLines = splitTextElToLines(openingHeaderEl);
            const heroLines = splitTextElToLines(heroTitleEl);
            if (window.gsap && heroLines.length) {
              gsap.set(heroLines, { yPercent: 110 });
            }
            // Ensure opening video starts off-screen.
            // Important: remove any CSS `transform: translateY(110%)` first so GSAP doesn't inherit it as extra pixels.
            if (window.gsap && openingVideoEl) {
              openingVideoEl.style.transform = "none";
              gsap.set(openingVideoEl, { x: 0, y: 0, yPercent: 110, transformOrigin: "50% 50%" });
            }

            // Fallback if GSAP is missing: wait, then hide preloader at 100%
            if (!window.gsap) {
              window.setTimeout(() => {
                setActiveFrame(0);
                progressEl.textContent = "100%";
                document.body.classList.remove("is-loading");
                window.__preloaderDone = true;
                resolve({ preloaderSection, frames, progressEl });
              }, 2500);
              return;
            }

            // Don't show the first "HUMANS DON'T CHANGE..." overlay until the pinned scroll begins.
            gsap.set(videoTextEl, { visibility: "hidden" });
            gsap.set(videoTextInners, { yPercent: 140 });

            // Keep the "gif" frames cycling continuously (independent of progress),
            // so it keeps looping during the FLIP move and after.
            let frameLoopCall = null;
            const FRAME_STEP = 0.17; // seconds per frame (bigger = slower)
            let frameIdx = 0;
            const tickFrameLoop = () => {
              setActiveFrame(frameIdx);
              frameIdx = (frameIdx + 1) % frames.length;
              frameLoopCall = gsap.delayedCall(FRAME_STEP, tickFrameLoop);
            };
            tickFrameLoop();

            // FLIP-style move for .gif-effect: transform-based for smoothness (no janky left/top animation).
            // Target (as requested):
            //   height: 16.847vw; width: 10.875vw; left: 0.625vw; top: 3.194vw; z-index: 999
            const flipGifToBannerTarget = () => {
              if (!gifEffectEl) return gsap.timeline();

              const vwToPx = (vw) => (window.innerWidth * vw) / 100;
              const containerRect = preloaderSection.getBoundingClientRect();
              const startRect = gifEffectEl.getBoundingClientRect();

              const destLeft = vwToPx(0.625);
              const destTop = vwToPx(3.194);
              const destWidth = vwToPx(10.875);
              const destHeight = vwToPx(16.847);

              // Place element at its FINAL position/sizing (absolute), then invert via transforms
              gsap.set(gifEffectEl, {
                position: "absolute",
                left: destLeft,
                top: destTop,
                width: destWidth,
                height: destHeight,
                zIndex: 999,
                margin: 0,
              });

              const finalLeftOnPage = containerRect.left + destLeft;
              const finalTopOnPage = containerRect.top + destTop;

              const dx = startRect.left - finalLeftOnPage;
              const dy = startRect.top - finalTopOnPage;
              const sx = startRect.width / destWidth;
              const sy = startRect.height / destHeight;

              gsap.set(gifEffectEl, {
                transformOrigin: "0 0",
                x: dx,
                y: dy,
                scaleX: sx,
                scaleY: sy,
              });

              return gsap.to(gifEffectEl, {
                x: 0,
                y: 0,
                scaleX: 1,
                scaleY: 1,
                duration: 0.85,
                ease: "power3.inOut",
                overwrite: true,
              });
            };

            // Fake progress (not tied to real load time)
            const DURATION = 2.5; // set 2.0-3.0 if you want
            const prog = { v: 0 };

            gsap.timeline({
              defaults: { ease: "none" },
            })
              .to(prog, {
                v: 100,
                duration: DURATION,
                onUpdate: () => {
                  const pct = Math.round(prog.v);
                  progressEl.textContent = `${pct}%`;
                },
              })
              // 100% reached -> hide opening header + progress (masked "down" motion)
              .to([...(openingLines || []), progressText].filter(Boolean), {
                yPercent: 120,
                duration: 0.3,
                ease: "power3.in",
                stagger: 0.03,
                overwrite: true,
              })
              // Move the gif into its banner position (smooth)
              .add(flipGifToBannerTarget())
              // Small buffer so the gif "lands" before the hero text reveals (not too long)
              .to({}, { duration: 0.1 })
              // Reveal hero banner title with a masked translate-up
              .to(heroLines, {
                yPercent: 0,
                duration: 0.7,
                ease: "power3.out",
                overwrite: true,
                stagger: 0.06,
              })
              // After the banner text comes up, bring the video up to 50%
              .to(openingVideoEl, {
                yPercent: 0,
                duration: 0.9,
                ease: "power3.out",
                overwrite: true,
              })
              .call(() => {
                document.body.classList.remove("is-loading");
                window.__preloaderDone = true;
                resolve({ preloaderSection, frames, progressEl });
              });
          });
        }

        function initLenis() {
          if (!window.Lenis) {
            console.log("[Lenis] not found on window");
            return;
          }

          const lenis = new Lenis({
            duration: 1.1,
            smoothWheel: true,
            smoothTouch: true,
            gestureOrientation: "vertical",
          });
          console.log("Lenis loaded?", !!window.Lenis);
          console.log("Lenis instance", lenis);

          // Drive your CSS variable (--progress) from Lenis' animated scroll position.
          // This sets progress 0..1 over the whole page scroll range.
          const revolverWrapper = document.querySelector(".revolver-wrapper");
          const clamp01 = (v) => Math.max(0, Math.min(1, v));
          // Bigger = faster rotation response (0.35 was fairly subtle)
          const PROGRESS_MULT = 0.6;
          const getMaxScroll = () =>
            Math.max(1, document.documentElement.scrollHeight - window.innerHeight);

          lenis.on("scroll", (e) => {
            console.log("lenis scroll", e.animatedScroll);

            if (revolverWrapper) {
              const progress = clamp01(e.animatedScroll / getMaxScroll());
              revolverWrapper.style.setProperty(
                "--progress",
                (progress * PROGRESS_MULT).toFixed(4)
              );
            }
          });
          window.lenis = lenis;

          if (window.gsap && window.ScrollTrigger && gsap.registerPlugin) {
            gsap.registerPlugin(ScrollTrigger);
          }

          if (window.ScrollTrigger) {
            lenis.on("scroll", ScrollTrigger.update);
          }

          // Revolver section (non-pinned) reveal.
          // IMPORTANT: The hero above is pinned. While pinned, the document still scrolls "underneath",
          // so a normal start like "top 80%" can be reached before the revolver is actually visible.
          // Workaround: we only ARM the revolver reveal after the pinned hero ScrollTrigger finishes.
          const armRevolverReveal = (() => {
            let armed = false;
            let middleRevealTl = null;
            let sideRevealTl = null;
            let builtCache = null;

            return () => {
              if (armed || !window.ScrollTrigger) return;
              const revolverSection = document.querySelector(".revolver-parent");
              if (!revolverSection) return;
              armed = true;

              const buildRevolverReveal = () => {
                if (builtCache) return builtCache;

                const rightTextEl = revolverSection.querySelector(".right-text h5");
                const middleSubheadEl = revolverSection.querySelector(".middle-text .subhead");
                const middleHeadlineEl = revolverSection.querySelector(".middle-text .h4");
                const middleBtnEl = revolverSection.querySelector(".middle-text .custom-button");
                const squiggly2El = revolverSection.querySelector(".squiggly-gif-2");

                const rightLines = splitTextElToLines(rightTextEl);
                const subheadLines = splitTextElToLines(middleSubheadEl);
                const headlineLines = wrapBrSeparatedLinesToMasks(middleHeadlineEl);

                const resetMiddle = () => {
                  gsap.set([middleSubheadEl, middleHeadlineEl, middleBtnEl].filter(Boolean), { visibility: "hidden" });
                  gsap.set([...subheadLines, ...headlineLines], { yPercent: 120 });
                  gsap.set(middleBtnEl, { autoAlpha: 0, y: 10 });
                  if (middleRevealTl) middleRevealTl.pause(0);
                };

                const resetSide = () => {
                  gsap.set([rightTextEl].filter(Boolean), { visibility: "hidden" });
                  gsap.set(rightLines, { yPercent: 120 });
                  gsap.set(squiggly2El, { autoAlpha: 0, y: 16, filter: "blur(.694vw)" });
                  if (sideRevealTl) sideRevealTl.pause(0);
                };

                const resetAll = () => {
                  resetMiddle();
                  resetSide();
                };

                // Hidden baseline
                resetAll();

                middleRevealTl = gsap
                  .timeline({ paused: true })
                  .set([middleSubheadEl, middleHeadlineEl, middleBtnEl].filter(Boolean), { visibility: "visible" }, 0)
                  .to(subheadLines, { yPercent: 0, duration: 0.65, ease: "power3.out", stagger: 0.08 }, 0.05)
                  .to(headlineLines, { yPercent: 0, duration: 0.75, ease: "power3.out", stagger: 0.08 }, 0.12)
                  .to(middleBtnEl, { autoAlpha: 1, y: 0, duration: 0.55, ease: "power3.out" }, 0.22);

                sideRevealTl = gsap
                  .timeline({ paused: true })
                  .set([rightTextEl].filter(Boolean), { visibility: "visible" }, 0)
                  .to(squiggly2El, { autoAlpha: 1, y: 0, filter: "blur(0vw)", duration: 0.7, ease: "power3.out" }, 0)
                  .to(rightLines, { yPercent: 0, duration: 0.75, ease: "power3.out", stagger: 0.03 }, 0.12);

                builtCache = {
                  middleRevealTl,
                  sideRevealTl,
                  resetMiddle,
                  resetSide,
                  resetAll,
                  squiggly2El,
                };
                return builtCache;
              };

              // Now that we're armed, these triggers are safe to use.
              ScrollTrigger.create({
                trigger: revolverSection,
                start: "top 50%",
                onEnter: () => {
                  const built = buildRevolverReveal();
                  if (!built) return;
                  built.resetMiddle && built.resetMiddle();
                  built.middleRevealTl && built.middleRevealTl.play(0);
                },
                onEnterBack: () => {
                  const built = buildRevolverReveal();
                  if (!built) return;
                  built.resetMiddle && built.resetMiddle();
                  built.middleRevealTl && built.middleRevealTl.play(0);
                },
              });

              // Later trigger for the right-text + squiggly (uses the element itself as trigger)
              ScrollTrigger.create({
                trigger: revolverSection.querySelector(".squiggly-gif-2") || revolverSection.querySelector(".right-text") || revolverSection,
                start: "top 80%",
                onEnter: () => {
                  const built = buildRevolverReveal();
                  if (!built) return;
                  built.resetSide && built.resetSide();
                  built.sideRevealTl && built.sideRevealTl.play(0);
                },
                onEnterBack: () => {
                  const built = buildRevolverReveal();
                  if (!built) return;
                  built.resetSide && built.resetSide();
                  built.sideRevealTl && built.sideRevealTl.play(0);
                },
              });

              // Global reset when the entire revolver section leaves the viewport.
              ScrollTrigger.create({
                trigger: revolverSection,
                start: "top bottom",
                end: "bottom top",
                onLeave: () => {
                  const built = buildRevolverReveal();
                  built && built.resetAll && built.resetAll();
                },
                onLeaveBack: () => {
                  const built = buildRevolverReveal();
                  built && built.resetAll && built.resetAll();
                },
              });
            };
          })();

          /* ADDED BY AI START */
          // Test pinning: when the bottom of the preloader section hits the bottom of the viewport,
          // pin it for a couple "screens" worth of scroll.
          // While pinned, smoothly morph the opening video container to the requested size/radius.
          if (window.ScrollTrigger) {
            const preloaderSection = document.querySelector(".preloader-to-banner");
            if (preloaderSection) {
              const openingVideoEl = document.querySelector(".opening-video");
              const globeEl = document.querySelector(".opening-video .globe");
              const videoTextEl = document.querySelector(".opening-video .video-text");
              const videoTextInners = videoTextEl ? Array.from(videoTextEl.querySelectorAll(".video-text-inner")) : [];
              const videoTextNextEl = document.querySelector(".opening-video .video-text-next");
              const videoTextNextInners = videoTextNextEl ? Array.from(videoTextNextEl.querySelectorAll(".video-text-inner")) : [];
              const videoTextFinalEl = document.querySelector(".opening-video .video-text-final");
              const videoTextFinalLines = videoTextFinalEl ? Array.from(videoTextFinalEl.querySelectorAll(".line")) : [];
              const absoTop = document.querySelector(".abso-content .top-texts");
              const absoMiddle = document.querySelector(".abso-content .middle-text");
              const absoSquiggly = document.querySelector(".abso-content .squiggly-gif-container");
              const absoTopLines = absoTop ? Array.from(absoTop.querySelectorAll(".abso-line")) : [];
              const absoMiddleLines = absoMiddle ? Array.from(absoMiddle.querySelectorAll(".abso-line")) : [];
              const absoGuy = document.querySelector(".abso-content #guy");
              const absoTopLeft = document.querySelector(".abso-content #top-left");
              const absoTopRight = document.querySelector(".abso-content #topright");
              const absoBottomRight = document.querySelector(".abso-content #bottom-right");

              gsap.timeline({
                scrollTrigger: {
                  trigger: preloaderSection,
                  start: "bottom bottom",
                  end: "+=620%", // hold -> video-text out -> shrink -> globe in -> new text in -> final h2 in
                  pin: true,
                  pinSpacing: true,
                  scrub: 1,
                  invalidateOnRefresh: true,
                  // Arm the next section's reveal only after this pin finishes (prevents early firing).
                  onLeave: () => armRevolverReveal(),
                },
              })
                // Keep globe fully hidden until we're ready to slide it in
                .set(globeEl, { visibility: "hidden", y: 500 }, 0)
                // Keep the next message hidden until after globe
                .set(videoTextNextEl, { visibility: "hidden" }, 0)
                .set(videoTextNextInners, { yPercent: 140 }, 0)
                // Keep the final message hidden until after "WE CHANGE IT / TOGETHER"
                .set(videoTextFinalEl, { visibility: "hidden" }, 0)
                .set(videoTextFinalLines, { yPercent: 140 }, 0)
                // Start with the first video-text hidden/offscreen; we'll reveal it as the first pinned phase.
                .set(videoTextEl, { visibility: "hidden" }, 0)
                .set(videoTextInners, { yPercent: 140 }, 0)
                // Abso-content: ensure hidden initially + set initial transforms
                .set([absoTop, absoMiddle, absoSquiggly, absoGuy, absoTopLeft, absoTopRight, absoBottomRight].filter(Boolean), { visibility: "hidden" }, 0)
                .set([...absoTopLines, ...absoMiddleLines], { yPercent: 120 }, 0)
                .set(absoSquiggly, { autoAlpha: 0, y: 16, filter: "blur(.694vw)" }, 0)
                // Start the images off-screen (transform only), so they can animate into their final CSS positions.
                // #guy should come up from bottom (no diagonal), so only Y is offset.
                .set(absoGuy, { x: 0, y: () => window.innerHeight * 0.65 }, 0)
                // Push these further outside the viewport so the fly-in feels more dramatic
                .set(absoTopLeft, { x: () => -window.innerWidth * 0.55, y: () => -window.innerHeight * 0.35 }, 0)
                .set(absoTopRight, { x: () => window.innerWidth * 0.60, y: () => -window.innerHeight * 0.30 }, 0)
                .set(absoBottomRight, { x: () => window.innerWidth * 0.55, y: () => window.innerHeight * 0.45 }, 0)
                // Phase 1: reveal the first pill text AFTER the pin starts (as you scroll)
                .set(videoTextEl, { visibility: "visible" }, ">0")
                .to(videoTextInners, { yPercent: 0, duration: 0.55, ease: "none", stagger: 0.1 }, ">0")
                // Phase 2: hold for a bit so it's readable
                .to({}, { duration: 0.9 })
                // Phase 3: sink each pill into its own "floor" (masked by overflow-hidden on .video-text-pill)
                .to(videoTextInners, { yPercent: 140, duration: 0.7, ease: "none", stagger: 0.1 }, ">0")
                .set(videoTextEl, { visibility: "hidden" })
                // Second phase: shrink the video container
                .to(openingVideoEl, {
                  width: "48.958vw",
                  height: "25.556vw",
                  borderRadius: "21.944vw",
                  // Lift up so its bottom ends ~10.833vw above the section bottom after scaling
                  // (use px so it stays consistent, and invalidateOnRefresh recalculates on resize)
                  y: () => -((window.innerWidth * 10.833) / 100),
                  ease: "none",
                  transformOrigin: "50% 50%",
                  duration: 1,
                }, ">0")
                // After scaling finishes, slide the globe up on top of the video
                // Only starts when you continue scrolling after the scale is done
                .set(globeEl, { visibility: "visible" }, ">0")
                .to(globeEl, { y: 0, duration: 1, ease: "none" }, ">0")
                // While globe is sliding up, reveal top/middle text (masked) + squiggly (fade+blur+up)
                .set([absoTop, absoMiddle, absoSquiggly, absoGuy, absoTopLeft, absoTopRight, absoBottomRight].filter(Boolean), { visibility: "visible" }, "<0.35")
                .to(absoTopLines, { yPercent: 0, duration: 0.65, ease: "none", stagger: 0.08 }, "<0.35")
                .to(absoMiddleLines, { yPercent: 0, duration: 0.65, ease: "none" }, "<0.42")
                .to(absoSquiggly, { autoAlpha: 1, y: 0, filter: "blur(0vw)", duration: 0.65, ease: "none" }, "<0.35")
                // Images fly in: Top-left + Bottom-right together, then Guy + Top-right
                // Easing goal: fast acceleration -> slow brake (strong ease-out), with each image having its own feel.
                .to(absoTopLeft, { x: 0, y: 0, duration: 0.9, ease: "expo.out" }, "<0.30")
                .to(absoBottomRight, { x: 0, y: 0, duration: 0.95, ease: "power4.out" }, "<0.30")
                .to(absoGuy, { x: 0, y: 0, duration: 1.05, ease: "power4.out" }, "<0.52")
                .to(absoTopRight, { x: 0, y: 0, duration: 1.0, ease: "circ.out" }, "<0.52")
                // After globe, reveal the new 2-line pill text (masked up into view)
                .set(videoTextNextEl, { visibility: "visible" }, ">0")
                .to(videoTextNextInners, { yPercent: 0, duration: 0.7, ease: "none", stagger: 0.1 }, ">0")
                // Swap to final H2 message
                .to(videoTextNextInners, { yPercent: 140, duration: 0.55, ease: "none", stagger: 0.08 }, ">0.4")
                .set(videoTextNextEl, { visibility: "hidden" })
                .set(videoTextFinalEl, { visibility: "visible" })
                .to(videoTextFinalLines, { yPercent: 0, duration: 0.8, ease: "none", stagger: 0.1 }, ">0");
            }
          }
          /* ADDED BY AI END */

          if (window.gsap && gsap.ticker) {
            gsap.ticker.add((t) => lenis.raf(t * 1000));
            gsap.ticker.lagSmoothing(0);
          } else {
            const raf = (time) => {
              lenis.raf(time);
              requestAnimationFrame(raf);
            };
            requestAnimationFrame(raf);
          }
        }

        // Global cursor parallax for floating abso-content assets.
        // Important: apply transforms to inner <img> so ScrollTrigger can keep controlling the container position.
        function initAbsoHoverMicro() {
          if (!window.gsap) return;
          const finePointer =
            window.matchMedia &&
            window.matchMedia("(pointer: fine)").matches;
          if (!finePointer) return;

          // Controls you can tweak (per element):
          // - x/y: strength multiplier (use negatives to invert direction)
          // - duration/ease: how "floaty" the follow feels
          const PARALLAX_BASE = { x: 23, y: 17 }; // px, global strength
          const PARALLAX = {
            ".abso-content #top-left": { x: 1.05, y: 1.0, duration: 0.55, ease: "power3.out" },
            ".abso-content #bottom-right": { x: 1.1, y: 1.05, duration: 0.6, ease: "power4.out" },
            ".abso-content #topright": { x: 0.9, y: 0.85, duration: 0.55, ease: "circ.out" },
            ".abso-content #guy": { x: 0.75, y: 0.7, duration: 0.7, ease: "power3.out" },
            ".abso-content .squiggly-gif-container": { x: 1.25, y: 1.15, duration: 0.5, ease: "expo.out" },
          };

          const items = Object.entries(PARALLAX)
            .map(([selector, cfg]) => {
              const el = document.querySelector(selector);
              if (!el) return null;
              const target = el.querySelector("img") || el;
              target.style.willChange = "transform";
              return {
                target,
                cfg,
                xTo: gsap.quickTo(target, "x", { duration: cfg.duration, ease: cfg.ease }),
                yTo: gsap.quickTo(target, "y", { duration: cfg.duration, ease: cfg.ease }),
              };
            })
            .filter(Boolean);

          const onMove = (e) => {
            const nx = (e.clientX / Math.max(1, window.innerWidth) - 0.5) * 2;  // -1..1
            const ny = (e.clientY / Math.max(1, window.innerHeight) - 0.5) * 2; // -1..1
            items.forEach(({ xTo, yTo, cfg }) => {
              xTo(nx * PARALLAX_BASE.x * cfg.x);
              yTo(ny * PARALLAX_BASE.y * cfg.y);
            });
          };

          const reset = () => {
            items.forEach(({ xTo, yTo }) => {
              xTo(0);
              yTo(0);
            });
          };

          window.addEventListener("pointermove", onMove, { passive: true });
          window.addEventListener("pointerleave", reset);
          window.addEventListener("blur", reset);
        }

        runPreloader().then(initLenis);
        initAbsoHoverMicro();
        /* ADDED BY AI END */
      });
    })();
  </script>
</body>

</html>