<!doctype html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>Latest</title>
		<!-- ADDED BY AI START -->
		<link rel="stylesheet" href="https://use.typekit.net/cdf4adh.css" />
		<link rel="stylesheet" href="styles.css" />
		<!-- Handwriting font for Lottie animation fallback -->
		<link rel="preconnect" href="https://fonts.googleapis.com" />
		<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
		<link
			href="https://fonts.googleapis.com/css2?family=Caveat:wght@400;700&display=swap"
			rel="stylesheet"
		/>
		<style>
			/* Font fallback for Lottie animation */
			@font-face {
				font-family: 'AdobeHandwriting-Frank';
				src: local('Caveat'), local('Caveat-Regular');
			}
			@font-face {
				font-family: 'Adobe Handwriting';
				src: local('Caveat'), local('Caveat-Regular');
			}
		</style>
		<!-- ADDED BY AI END -->
		<script>
			/* ADDED BY AI START */
			// Always start at the top on refresh / page load (disable scroll restoration).
			// Handles normal reloads + bfcache restores (Safari/Chrome back-forward cache).
			if ('scrollRestoration' in history) {
				history.scrollRestoration = 'manual';
			}

			const scrollToTop = () => {
				window.scrollTo(0, 0);
				// Some browsers apply scroll restoration after load; do a couple extra ticks.
				requestAnimationFrame(() => window.scrollTo(0, 0));
				setTimeout(() => window.scrollTo(0, 0), 0);
			};

			window.addEventListener('DOMContentLoaded', scrollToTop, { once: true });
			window.addEventListener('pageshow', scrollToTop);
			/* ADDED BY AI END */
		</script>
	</head>

	<body>
		<div class="grain-overlay"></div>

		<section class="preloader-to-banner grain-effect">
			<div class="wrapper">
				<div class="preloader">
					<div class="gif-effect">
						<img id="to-banner" src="./assets/h-1.png" alt="" />
						<img src="./assets/h-2.png" alt="" />
						<img src="./assets/h-3.png" alt="" />
					</div>

					<div class="opening-header">
						<!-- ADDED BY AI START -->
						<!-- Mask wrapper for "slide down/out" animation -->
						<div class="mask">
							<h4 class="h4">
								To be human is to be <br />
								a part of something <br />
								bigger
							</h4>
						</div>
						<!-- ADDED BY AI END -->
					</div>

					<div class="progress">
						<!-- ADDED BY AI START -->
						<!-- Mask wrapper for "slide down/out" animation -->
						<div class="mask">
							<h6>0%</h6>
						</div>
						<!-- ADDED BY AI END -->
					</div>
				</div>

				<div class="hero-banner has-triple-line">
					<div class="wrapper">
						<div class="top">
							<!-- ADDED BY AI START -->
							<!-- Mask wrapper for "reveal from floor" animation -->
							<div class="mask hero-title-mask">
								<h1 class="h1 moret">UMAN-I-TEES</h1>
							</div>
							<!-- ADDED BY AI END -->
						</div>

						<div class="bottom">
							<div class="opening-video">
								<div class="video-text">
									<!-- ADDED BY AI START -->
									<!-- Video-text: TWO pills (one per <br> line). Each pill masks its own inner content "down into the floor". -->
									<div class="video-text-pill">
										<div class="video-text-inner">
											<div class="video-text-bg" aria-hidden="true"></div>
											<div class="video-text-text">
												<h4 class="h4">HUMANS DON'T CHANGE</h4>
											</div>
										</div>
									</div>

									<div class="video-text-pill">
										<div class="video-text-inner">
											<div class="video-text-bg" aria-hidden="true"></div>
											<div class="video-text-text">
												<h4 class="h4">
													THE WORLD
													<img src="./assets/video-text-icon.png" alt="" />
													ALONE
												</h4>
											</div>
										</div>
									</div>
									<!-- ADDED BY AI END -->
								</div>

								<!-- ADDED BY AI START -->
								<!-- Second message: reveal after globe slides up -->
								<div class="video-text video-text-next" aria-hidden="true">
									<div class="video-text-pill">
										<div class="video-text-inner">
											<div class="video-text-bg" aria-hidden="true"></div>
											<div class="video-text-text">
												<h4 class="h4">WE CHANGE IT</h4>
											</div>
										</div>
									</div>

									<div class="video-text-pill">
										<div class="video-text-inner">
											<div class="video-text-bg" aria-hidden="true"></div>
											<div class="video-text-text">
												<h4 class="h4">TOGETHER</h4>
											</div>
										</div>
									</div>
								</div>
								<!-- ADDED BY AI END -->

								<!-- ADDED BY AI START -->
								<!-- Third message: reveal after "WE CHANGE IT / TOGETHER" -->
								<div class="video-text-final" aria-hidden="true">
									<h2 class="h2">
										<span class="line-mask"
											><span class="line">One story, one choice</span></span
										>
										<span class="line-mask"
											><span class="line">at a time.</span></span
										>
									</h2>
								</div>
								<!-- ADDED BY AI END -->
								<video
									src="./assets/banner-video.mp4"
									autoplay
									muted
									loop
									playsinline
									preload="auto"
								></video>
								<!-- ADDED BY AI START -->
								<!-- Globe overlay (animated in during the pinned scroll) -->
								<img
									class="globe"
									src="./assets/globe.png"
									alt=""
									aria-hidden="true"
								/>
								<!-- ADDED BY AI END -->
							</div>
						</div>

						<div class="abso-content">
							<div class="top-texts">
								<h6><span class="abso-line">VOLUME 01</span></h6>
								<h6>
									<span class="abso-line"
										>THE BEGINNING OF SOMETHING BIGGER</span
									>
								</h6>
							</div>

							<div class="squiggly-gif-container">
								<img src="./assets/Wear_What_Matters_Black.gif" alt="" />
							</div>

							<div class="middle-text">
								<h6>
									<span class="abso-line"
										>In a world of noise, the most powerful voice is one that
										stands for others.</span
									>
								</h6>
							</div>

							<div id="top-left">
								<img src="./assets/top-left.png" alt="" />
							</div>

							<div id="guy">
								<img src="./assets/guy.png" alt="" />
							</div>

							<div id="topright">
								<img src="./assets/top-right.png" alt="" />
							</div>

							<div id="bottom-right">
								<img src="./assets/bottom-right.png" alt="" />
							</div>
						</div>
					</div>
				</div>
			</div>
		</section>

		<div class="revolver-parent has-triple-line line-black grain-effect">
			<div class="squiggly-gif-2">
				<img src="./assets/Stand together.gif" alt="" />
			</div>

			<div class="right-text">
				<h5 class="h5 dark">
					HUMANITEES, The name is a mashup of “Humanity” and “Tees.” It’s about
					connecting people through clothing and standing for something bigger
					than ourselves.
				</h5>
			</div>

			<div class="revolver-center">
				<div class="middle-text">
					<h5 class="h5 subhead dark">STARTED BACK IN THE 90S</h5>
					<h4 class="h4 dark">
						WE MAKE CLOTHING THAT SPARKS <br />
						CONVERSATION AND DRIVE ACTION, <br />
						DONATING 1
						<img class="dollar-icon" src="./assets/dollar-icon.png" alt="" />
						FROM EVERY SHIRT <br />
						TO OUR PLANET.
					</h4>

					<a href="#" class="custom-button">About</a>
				</div>

				<div class="revolver-wrapper">
					<div style="--revolver-index: 0" class="revolver-item">
						<img src="./assets/Group 54.png" alt="" />
					</div>
					<div style="--revolver-index: 1" class="revolver-item">
						<img src="./assets/Group 54.png" alt="" />
					</div>
					<div style="--revolver-index: 2" class="revolver-item">
						<img src="./assets/Group 54.png" alt="" />
					</div>
					<div style="--revolver-index: 3" class="revolver-item">
						<img src="./assets/Group 54.png" alt="" />
					</div>
					<div style="--revolver-index: 4" class="revolver-item">
						<img src="./assets/Group 54.png" alt="" />
					</div>
					<div style="--revolver-index: 5" class="revolver-item">
						<img src="./assets/Group 54.png" alt="" />
					</div>
					<div style="--revolver-index: 6" class="revolver-item">
						<img src="./assets/Group 54.png" alt="" />
					</div>
					<div style="--revolver-index: 7" class="revolver-item">
						<img src="./assets/Group 54.png" alt="" />
					</div>
					<div style="--revolver-index: 8" class="revolver-item">
						<img src="./assets/Group 54.png" alt="" />
					</div>
					<div style="--revolver-index: 9" class="revolver-item">
						<img src="./assets/Group 54.png" alt="" />
					</div>
					<div style="--revolver-index: 10" class="revolver-item">
						<img src="./assets/Group 54.png" alt="" />
					</div>
					<div style="--revolver-index: 11" class="revolver-item">
						<img src="./assets/Group 54.png" alt="" />
					</div>
				</div>
			</div>

			<section class="invitation">
				<p class="body dark">AN INVITATION FOR YOU</p>
				<img src="./assets/invitation-bg.png" alt="" />

				<div class="after-fullw-wrapper">
					<div class="center">
						<h4 class="h4 dark">THIS IS YOUR INVITATION</h4>
						<h2 class="h2">
							BE A PART OF A STORY <br />
							THAT MATTERS
						</h2>
						<a href="#" class="custom-button">Support Our Cause</a>
					</div>

					<img src="./assets/Stand together.gif" alt="" />
				</div>
			</section>

			<img id="wax" src="./assets/crop wax 1.png" alt="" />
			<img id="paper" src="./assets/invitation-behind.png" alt="" />

			<!-- <div class="pinning-wrapper">
      <div class="pinning-content">
        <img src="./assets/invitation-behind.png" alt="">
        <img src="./assets/crop wax 1.png" alt="">
        <img id="pinning-bg" src="./assets/revolver-bottom-pin-bg.png" alt="">
      </div>
    </div> -->
		</div>

		<section class="clonable-prefooter has-triple-line line-black">
			<img id="stand-together-gif" class="lottie-animation" alt="" />
			<div class="container">
				<h1 class="h1">Join The <br />Movement</h1>
			</div>

			<div class="medias">
				<!-- Only include images that actually exist in /assets -->
				<img src="./assets/clonable-prefooter-1.png" alt="" />
				<img src="./assets/clonable-prefooter-2.png" alt="" />
				<img src="./assets/clonable-prefooter-3.png" alt="" />
				<img src="./assets/clonable-prefooter-4.png" alt="" />
			</div>
		</section>

		<!-- Lenis + GSAP -->
		<!-- Lenis (CDN fallback: jsDelivr -> unpkg) -->
		<script
			src="https://cdn.jsdelivr.net/npm/lenis@1.3.4/dist/lenis.min.js"
			onerror="
				this.onerror = null;
				this.src = 'https://unpkg.com/lenis@1.3.4/dist/lenis.min.js';
			"
		></script>
		<script src="https://cdn.jsdelivr.net/npm/gsap@3.12.5/dist/gsap.min.js"></script>
		<script src="https://cdn.jsdelivr.net/npm/gsap@3.12.5/dist/ScrollTrigger.min.js"></script>
		<script>
			(function () {
				function onReady(fn) {
					if (window.jQuery) {
						jQuery(fn);
						return;
					}
					if (document.readyState === 'loading')
						document.addEventListener('DOMContentLoaded', fn, { once: true });
					else fn();
				}

				onReady(function () {
					/* ADDED BY AI START */
					// Triple-line injection + reveal (delayed until AFTER the preloader finishes).
					function injectTripleLines(hosts, { variant } = {}) {
						const markup = `
    <div class="triple-line-wrapper" data-auto-triple-line="true" data-triple-line-variant="${variant || 'static'}">
      <div class="line"></div>
      <div class="line"></div>
      <div class="line"></div>
    </div>
          `.trim();

						hosts.forEach((host) => {
							// Only check for a direct child to avoid blocking intentional nested usages elsewhere.
							if (host.querySelector(':scope > .triple-line-wrapper')) return;

							// Ensure absolutely-positioned wrapper has a sane containing block.
							const pos = window.getComputedStyle(host).position;
							if (pos === 'static') host.style.position = 'relative';

							host.insertAdjacentHTML('afterbegin', markup);
						});
					}

					function injectNonPreloaderTripleLines() {
						const hosts = Array.from(
							document.querySelectorAll('.has-triple-line'),
						).filter((el) => !el.closest('.preloader-to-banner'));
						injectTripleLines(hosts, { variant: 'static' });
					}

					function injectPreloaderTripleLines() {
						const hosts = Array.from(
							document.querySelectorAll(
								'.preloader-to-banner .has-triple-line',
							),
						);
						injectTripleLines(hosts, { variant: 'preloader' });
					}

					function animatePreloaderTripleLines() {
						if (!window.gsap) return;
						const wrappers = Array.from(
							document.querySelectorAll(
								".preloader-to-banner .has-triple-line > .triple-line-wrapper[data-triple-line-variant='preloader']",
							),
						);
						if (!wrappers.length) return;

						// Start above the viewport (safe because preloader section is at the very top),
						// then slide down smoothly into place.
						gsap.set(wrappers, { yPercent: -120 });
						gsap.to(wrappers, {
							yPercent: 0,
							duration: 3.2,
							ease: 'power3.out',
							stagger: 0.05,
						});
					}
					/* ADDED BY AI END */

					/* ADDED BY AI START */
					// Split text inside an element (e.g. H1/H4) into real rendered lines so we can animate line-by-line.
					// IMPORTANT: we keep the original element so your existing typography/styles still apply.
					// No plugins required (avoids GSAP SplitText).
					function splitTextElToLines(textEl) {
						if (!textEl) return [];

						// If already split, reuse existing lines
						const existing = Array.from(textEl.querySelectorAll('.line'));
						if (existing.length) return existing;

						// If author added <br> tags, treat them as HARD line breaks and follow them exactly.
						// This avoids reflow-based line detection and preserves your intended line structure.
						const hasBr = !!textEl.querySelector('br');
						if (hasBr) {
							const clone = textEl.cloneNode(true);
							clone
								.querySelectorAll('br')
								.forEach((br) => br.replaceWith(document.createTextNode('\n')));
							const parts = (clone.textContent || '')
								.split('\n')
								.map((s) => s.trim())
								.filter(Boolean);

							const frag = document.createDocumentFragment();
							const lineEls = [];

							parts.forEach((part) => {
								const lineMask = document.createElement('span');
								lineMask.className = 'line-mask';
								lineMask.style.display = 'block';
								lineMask.style.overflow = 'hidden';

								const line = document.createElement('span');
								line.className = 'line';
								line.style.display = 'block';

								const words = part.split(/\s+/).filter(Boolean);
								words.forEach((w, idx) => {
									const word = document.createElement('span');
									word.style.display = 'inline-block';
									word.textContent = w;
									line.appendChild(word);
									if (idx !== words.length - 1) {
										line.appendChild(document.createTextNode(' '));
									}
								});

								lineMask.appendChild(line);
								frag.appendChild(lineMask);
								lineEls.push(line);
							});

							textEl.innerHTML = '';
							textEl.appendChild(frag);
							return lineEls;
						}

						const text = (textEl.textContent || '').trim();
						if (!text) return [];

						// Turn the text into word spans so we can measure line breaks
						const words = text.split(/\s+/);
						textEl.textContent = '';

						const wordSpans = words.map((w) => {
							const span = document.createElement('span');
							span.style.display = 'inline-block';
							span.textContent = w;
							textEl.appendChild(span);
							// IMPORTANT: use a real text node space between inline-block spans
							// (trailing spaces inside spans can get collapsed and "disappear")
							textEl.appendChild(document.createTextNode(' '));
							return span;
						});
						// Remove the last trailing space node we added
						if (
							textEl.lastChild &&
							textEl.lastChild.nodeType === Node.TEXT_NODE
						) {
							textEl.removeChild(textEl.lastChild);
						}

						// Group words by offsetTop (each unique top == a new line)
						const lines = [];
						let currentTop = null;
						let currentLine = [];

						wordSpans.forEach((span) => {
							const top = span.offsetTop;
							if (currentTop === null) currentTop = top;
							if (top !== currentTop) {
								lines.push(currentLine);
								currentLine = [];
								currentTop = top;
							}
							currentLine.push(span);
						});
						if (currentLine.length) lines.push(currentLine);

						// Replace element contents with inline wrappers (valid inside H1/H4/H6)
						const frag = document.createDocumentFragment();
						const lineEls = [];

						lines.forEach((lineWords) => {
							const lineMask = document.createElement('span');
							lineMask.className = 'line-mask';
							lineMask.style.display = 'block';
							lineMask.style.overflow = 'hidden';

							const line = document.createElement('span');
							line.className = 'line';
							line.style.display = 'block';

							// Rebuild spans + spaces so spacing is guaranteed
							lineWords.forEach((wSpan, idx) => {
								const clone = wSpan.cloneNode(true);
								line.appendChild(clone);
								// Add a space after every word except the last word in the entire text
								// (trailing spaces at end of a block line won't show, so this is safe).
								const isLastWordOverall =
									wSpan === wordSpans[wordSpans.length - 1];
								if (!isLastWordOverall) {
									line.appendChild(document.createTextNode(' '));
								}
							});
							lineMask.appendChild(line);
							frag.appendChild(lineMask);
							lineEls.push(line);
						});

						textEl.innerHTML = '';
						textEl.appendChild(frag);

						return lineEls;
					}

					// Wrap <br>-separated lines without destroying inline elements (e.g. <img> inside a headline).
					// Returns the created `.line` elements (each inside a `.line-mask`).
					function wrapBrSeparatedLinesToMasks(textEl) {
						if (!textEl) return [];
						const existing = Array.from(
							textEl.querySelectorAll(':scope > .line-mask > .line'),
						);
						if (existing.length) return existing;

						const children = Array.from(textEl.childNodes);
						const lines = [];
						let buf = [];

						const flush = () => {
							// Keep empty lines out
							if (!buf.length) return;
							lines.push(buf);
							buf = [];
						};

						children.forEach((node) => {
							if (
								node.nodeType === Node.ELEMENT_NODE &&
								node.nodeName === 'BR'
							) {
								flush();
							} else {
								buf.push(node);
							}
						});
						flush();

						const frag = document.createDocumentFragment();
						const lineEls = [];
						lines.forEach((nodes) => {
							const lineMask = document.createElement('span');
							lineMask.className = 'line-mask';
							lineMask.style.display = 'block';
							lineMask.style.overflow = 'hidden';

							const line = document.createElement('span');
							line.className = 'line';
							line.style.display = 'block';
							line.style.willChange = 'transform';

							nodes.forEach((n) => line.appendChild(n));
							lineMask.appendChild(line);
							frag.appendChild(lineMask);
							lineEls.push(line);
						});

						textEl.innerHTML = '';
						textEl.appendChild(frag);
						return lineEls;
					}

					// Smooth preloader timeline:
					// - locks scroll
					// - cycles images like a "gif"
					// - counts 0% -> 100% over ~2.5s (not tied to real load)
					// - at 100%, forces the FIRST image to show and pauses there
					// - fades the preloader out and unlocks scroll
					//
					// Then we initialize Lenis AFTER the preloader, so nothing scroll-driven runs underneath.
					function runPreloader() {
						return new Promise((resolve) => {
							const preloaderSection = document.querySelector(
								'.preloader-to-banner',
							);
							const frames = Array.from(
								document.querySelectorAll('.gif-effect img'),
							);
							const progressEl = document.querySelector(
								'.preloader .progress h6',
							);
							const gifEffectEl = document.querySelector('.gif-effect');
							const openingHeaderEl = document.querySelector(
								'.opening-header .mask .h4',
							);
							const progressText = document.querySelector(
								'.progress .mask > *',
							);
							const heroTitleEl = document.querySelector(
								'.hero-banner .hero-title-mask .h1',
							);
							const openingVideoEl = document.querySelector('.opening-video');
							const videoTextEl = document.querySelector(
								'.opening-video .video-text',
							);
							const videoTextInners = videoTextEl
								? Array.from(videoTextEl.querySelectorAll('.video-text-inner'))
								: [];
							// before adding is-loading
							const sbw =
								window.innerWidth - document.documentElement.clientWidth;
							document.documentElement.style.setProperty('--sbw', sbw + 'px');

							if (!preloaderSection || frames.length === 0 || !progressEl) {
								document.documentElement.style.removeProperty('--sbw');
								resolve();
								return;
							}

							document.body.classList.add('is-loading');

							const setActiveFrame = (idx) => {
								frames.forEach((img, i) =>
									img.classList.toggle('is-active', i === idx),
								);
							};

							// Initial state
							setActiveFrame(0);
							progressEl.textContent = '0%';
							// Prepare line-by-line masks and initial hero hidden state
							const openingLines = splitTextElToLines(openingHeaderEl);
							const heroLines = splitTextElToLines(heroTitleEl);
							if (window.gsap && heroLines.length) {
								gsap.set(heroLines, { yPercent: 110 });
							}
							// Ensure opening video starts off-screen.
							// Important: remove any CSS `transform: translateY(110%)` first so GSAP doesn't inherit it as extra pixels.
							if (window.gsap && openingVideoEl) {
								openingVideoEl.style.transform = 'none';
								gsap.set(openingVideoEl, {
									x: 0,
									y: 0,
									yPercent: 110,
									transformOrigin: '50% 50%',
								});
							}

							// Fallback if GSAP is missing: wait, then hide preloader at 100%
							if (!window.gsap) {
								window.setTimeout(() => {
									setActiveFrame(0);
									progressEl.textContent = '100%';
									document.body.classList.remove('is-loading');
									document.documentElement.style.removeProperty('--sbw');
									window.__preloaderDone = true;
									resolve({ preloaderSection, frames, progressEl });
								}, 2500);
								return;
							}

							// Don't show the first "HUMANS DON'T CHANGE..." overlay until the pinned scroll begins.
							gsap.set(videoTextEl, { visibility: 'hidden' });
							gsap.set(videoTextInners, { yPercent: 140 });

							// Keep the "gif" frames cycling continuously (independent of progress),
							// so it keeps looping during the FLIP move and after.
							let frameLoopCall = null;
							const FRAME_STEP = 0.17; // seconds per frame (bigger = slower)
							let frameIdx = 0;
							const tickFrameLoop = () => {
								setActiveFrame(frameIdx);
								frameIdx = (frameIdx + 1) % frames.length;
								frameLoopCall = gsap.delayedCall(FRAME_STEP, tickFrameLoop);
							};
							tickFrameLoop();

							// FLIP-style move for .gif-effect: transform-based for smoothness (no janky left/top animation).
							// Target (as requested):
							//   height: 16.847vw; width: 10.875vw; left: 0.625vw; top: 3.194vw; z-index: 999
							const flipGifToBannerTarget = () => {
								if (!gifEffectEl) return gsap.timeline();

								const vwToPx = (vw) => (window.innerWidth * vw) / 100;
								const containerRect = preloaderSection.getBoundingClientRect();
								const startRect = gifEffectEl.getBoundingClientRect();

								const destLeft = vwToPx(0.625);
								const destTop = vwToPx(3.194);
								const destWidth = vwToPx(10.875);
								const destHeight = vwToPx(16.847);

								// Place element at its FINAL position/sizing (absolute), then invert via transforms
								gsap.set(gifEffectEl, {
									position: 'absolute',
									left: destLeft,
									top: destTop,
									width: destWidth,
									height: destHeight,
									zIndex: 999,
									margin: 0,
								});

								const finalLeftOnPage = containerRect.left + destLeft;
								const finalTopOnPage = containerRect.top + destTop;

								const dx = startRect.left - finalLeftOnPage;
								const dy = startRect.top - finalTopOnPage;
								const sx = startRect.width / destWidth;
								const sy = startRect.height / destHeight;

								gsap.set(gifEffectEl, {
									transformOrigin: '0 0',
									x: dx,
									y: dy,
									scaleX: sx,
									scaleY: sy,
								});

								return gsap.to(gifEffectEl, {
									x: 0,
									y: 0,
									scaleX: 1,
									scaleY: 1,
									duration: 0.85,
									ease: 'power3.inOut',
									overwrite: true,
								});
							};

							// Fake progress (not tied to real load time)
							const DURATION = 2.5; // set 2.0-3.0 if you want
							const prog = { v: 0 };

							gsap
								.timeline({
									defaults: { ease: 'none' },
								})
								.to(prog, {
									v: 100,
									duration: DURATION,
									onUpdate: () => {
										const pct = Math.round(prog.v);
										progressEl.textContent = `${pct}%`;
									},
								})
								// 100% reached -> hide opening header + progress (masked "down" motion)
								.to([...(openingLines || []), progressText].filter(Boolean), {
									yPercent: 120,
									duration: 0.3,
									ease: 'power3.in',
									stagger: 0.03,
									overwrite: true,
								})
								// Move the gif into its banner position (smooth)
								.add(flipGifToBannerTarget())
								// Small buffer so the gif "lands" before the hero text reveals (not too long)
								.to({}, { duration: 0.1 })
								// Reveal hero banner title with a masked translate-up
								.to(heroLines, {
									yPercent: 0,
									duration: 0.7,
									ease: 'power3.out',
									overwrite: true,
									stagger: 0.06,
								})
								// After the banner text comes up, bring the video up to 50%
								.to(openingVideoEl, {
									yPercent: 0,
									duration: 0.9,
									ease: 'power3.out',
									overwrite: true,
								})
								.call(() => {
									document.body.classList.remove('is-loading');
									document.documentElement.style.removeProperty('--sbw');
									window.__preloaderDone = true;
									resolve({ preloaderSection, frames, progressEl });
								});
						});
					}

					function initLenis() {
						if (!window.Lenis) {
							return;
						}

						const lenis = new Lenis({
							duration: 1.1,
							smoothWheel: true,
							smoothTouch: true,
							gestureOrientation: 'vertical',
						});

						// Drive your CSS variable (--progress) from Lenis' animated scroll position.
						// This sets progress 0..1 over the whole page scroll range.
						const revolverWrapper = document.querySelector('.revolver-wrapper');
						const clamp01 = (v) => Math.max(0, Math.min(1, v));
						// Bigger = faster rotation response (0.35 was fairly subtle)
						const PROGRESS_MULT = 0.6;
						const getMaxScroll = () =>
							Math.max(
								1,
								document.documentElement.scrollHeight - window.innerHeight,
							);

						lenis.on('scroll', (e) => {
							if (revolverWrapper) {
								const progress = clamp01(e.animatedScroll / getMaxScroll());
								revolverWrapper.style.setProperty(
									'--progress',
									(progress * PROGRESS_MULT).toFixed(4),
								);
							}
						});
						window.lenis = lenis;

						if (window.gsap && window.ScrollTrigger && gsap.registerPlugin) {
							gsap.registerPlugin(ScrollTrigger);
						}

						if (window.ScrollTrigger) {
							lenis.on('scroll', ScrollTrigger.update);
						}

						// Revolver section (non-pinned) reveal.
						// IMPORTANT: The hero above is pinned. While pinned, the document still scrolls "underneath",
						// so a normal start like "top 80%" can be reached before the revolver is actually visible.
						// Workaround: we only ARM the revolver reveal after the pinned hero ScrollTrigger finishes.
						const armRevolverReveal = (() => {
							let armed = false;
							let middleRevealTl = null;
							let sideRevealTl = null;
							let builtCache = null;
							// Play once only - never reset
							let middlePlayed = false;
							let sidePlayed = false;

							return () => {
								if (armed || !window.ScrollTrigger) return;
								const revolverSection =
									document.querySelector('.revolver-parent');
								if (!revolverSection) return;
								armed = true;

								const buildRevolverReveal = () => {
									if (builtCache) return builtCache;

									const rightTextEl =
										revolverSection.querySelector('.right-text h5');
									const middleSubheadEl = revolverSection.querySelector(
										'.middle-text .subhead',
									);
									const middleHeadlineEl =
										revolverSection.querySelector('.middle-text .h4');
									const middleBtnEl = revolverSection.querySelector(
										'.middle-text .custom-button',
									);
									const squiggly2El =
										revolverSection.querySelector('.squiggly-gif-2');

									const rightLines = splitTextElToLines(rightTextEl);
									const subheadLines = splitTextElToLines(middleSubheadEl);
									const headlineLines =
										wrapBrSeparatedLinesToMasks(middleHeadlineEl);

									// Set initial hidden state
									gsap.set(
										[middleSubheadEl, middleHeadlineEl, middleBtnEl].filter(
											Boolean,
										),
										{ visibility: 'hidden' },
									);
									gsap.set([...subheadLines, ...headlineLines], {
										yPercent: 120,
									});
									gsap.set(middleBtnEl, { autoAlpha: 0, y: 10 });
									gsap.set([rightTextEl].filter(Boolean), {
										visibility: 'hidden',
									});
									gsap.set(rightLines, { yPercent: 120 });
									gsap.set(squiggly2El, {
										autoAlpha: 0,
										y: 16,
										filter: 'blur(.694vw)',
									});

									middleRevealTl = gsap
										.timeline({ paused: true })
										.set(
											[middleSubheadEl, middleHeadlineEl, middleBtnEl].filter(
												Boolean,
											),
											{ visibility: 'visible' },
											0,
										)
										.to(
											subheadLines,
											{
												yPercent: 0,
												duration: 0.65,
												ease: 'power3.out',
												stagger: 0.08,
											},
											0.05,
										)
										.to(
											headlineLines,
											{
												yPercent: 0,
												duration: 0.75,
												ease: 'power3.out',
												stagger: 0.08,
											},
											0.12,
										)
										.to(
											middleBtnEl,
											{
												autoAlpha: 1,
												y: 0,
												duration: 0.55,
												ease: 'power3.out',
											},
											0.22,
										);

									sideRevealTl = gsap
										.timeline({ paused: true })
										.set(
											[rightTextEl].filter(Boolean),
											{ visibility: 'visible' },
											0,
										)
										.to(
											squiggly2El,
											{
												autoAlpha: 1,
												y: 0,
												filter: 'blur(0vw)',
												duration: 0.7,
												ease: 'power3.out',
											},
											0,
										)
										.to(
											rightLines,
											{
												yPercent: 0,
												duration: 0.75,
												ease: 'power3.out',
												stagger: 0.03,
											},
											0.12,
										);

									builtCache = {
										middleRevealTl,
										sideRevealTl,
										squiggly2El,
									};
									return builtCache;
								};

								// Middle text: play once only
								ScrollTrigger.create({
									trigger: revolverSection,
									start: 'top 50%',
									once: true,
									onEnter: () => {
										if (middlePlayed) return;
										const built = buildRevolverReveal();
										if (!built) return;
										built.middleRevealTl && built.middleRevealTl.play(0);
										middlePlayed = true;
									},
								});

								// Right text + squiggly: play once only
								ScrollTrigger.create({
									trigger:
										revolverSection.querySelector('.squiggly-gif-2') ||
										revolverSection.querySelector('.right-text') ||
										revolverSection,
									start: 'top 80%',
									once: true,
									onEnter: () => {
										if (sidePlayed) return;
										const built = buildRevolverReveal();
										if (!built) return;
										built.sideRevealTl && built.sideRevealTl.play(0);
										sidePlayed = true;
									},
								});
							};
						})();

						/* ADDED BY AI START */
						// Test pinning: when the bottom of the preloader section hits the bottom of the viewport,
						// pin it for a couple "screens" worth of scroll.
						// While pinned, smoothly morph the opening video container to the requested size/radius.
						if (window.ScrollTrigger) {
							const preloaderSection = document.querySelector(
								'.preloader-to-banner',
							);
							if (preloaderSection) {
								const openingVideoEl = document.querySelector('.opening-video');
								const globeEl = document.querySelector('.opening-video .globe');
								const videoTextEl = document.querySelector(
									'.opening-video .video-text',
								);
								const videoTextInners = videoTextEl
									? Array.from(
											videoTextEl.querySelectorAll('.video-text-inner'),
										)
									: [];
								const videoTextNextEl = document.querySelector(
									'.opening-video .video-text-next',
								);
								const videoTextNextInners = videoTextNextEl
									? Array.from(
											videoTextNextEl.querySelectorAll('.video-text-inner'),
										)
									: [];
								const videoTextFinalEl = document.querySelector(
									'.opening-video .video-text-final',
								);
								const videoTextFinalLines = videoTextFinalEl
									? Array.from(videoTextFinalEl.querySelectorAll('.line'))
									: [];
								const absoTop = document.querySelector(
									'.abso-content .top-texts',
								);
								const absoMiddle = document.querySelector(
									'.abso-content .middle-text',
								);
								const absoSquiggly = document.querySelector(
									'.abso-content .squiggly-gif-container',
								);
								const absoTopLines = absoTop
									? Array.from(absoTop.querySelectorAll('.abso-line'))
									: [];
								const absoMiddleLines = absoMiddle
									? Array.from(absoMiddle.querySelectorAll('.abso-line'))
									: [];
								const absoGuy = document.querySelector('.abso-content #guy');
								const absoTopLeft = document.querySelector(
									'.abso-content #top-left',
								);
								const absoTopRight = document.querySelector(
									'.abso-content #topright',
								);
								const absoBottomRight = document.querySelector(
									'.abso-content #bottom-right',
								);

								gsap
									.timeline({
										scrollTrigger: {
											trigger: preloaderSection,
											start: 'bottom bottom',
											end: '+=620%', // hold -> video-text out -> shrink -> globe in -> new text in -> final h2 in
											pin: true,
											pinSpacing: true,
											scrub: 1,
											invalidateOnRefresh: true,
											// Arm the next section's reveal only after this pin finishes (prevents early firing).
											onLeave: () => armRevolverReveal(),
										},
									})
									// Keep globe fully hidden until we're ready to slide it in
									.set(globeEl, { visibility: 'hidden', y: 500 }, 0)
									// Keep the next message hidden until after globe
									.set(videoTextNextEl, { visibility: 'hidden' }, 0)
									.set(videoTextNextInners, { yPercent: 140 }, 0)
									// Keep the final message hidden until after "WE CHANGE IT / TOGETHER"
									.set(videoTextFinalEl, { visibility: 'hidden' }, 0)
									.set(videoTextFinalLines, { yPercent: 140 }, 0)
									// Start with the first video-text hidden/offscreen; we'll reveal it as the first pinned phase.
									.set(videoTextEl, { visibility: 'hidden' }, 0)
									.set(videoTextInners, { yPercent: 140 }, 0)
									// Abso-content: ensure hidden initially + set initial transforms
									.set(
										[
											absoTop,
											absoMiddle,
											absoSquiggly,
											absoGuy,
											absoTopLeft,
											absoTopRight,
											absoBottomRight,
										].filter(Boolean),
										{ visibility: 'hidden' },
										0,
									)
									.set(
										[...absoTopLines, ...absoMiddleLines],
										{ yPercent: 120 },
										0,
									)
									.set(
										absoSquiggly,
										{ autoAlpha: 0, y: 16, filter: 'blur(.694vw)' },
										0,
									)
									// Start the images off-screen (transform only), so they can animate into their final CSS positions.
									// #guy should come up from bottom (no diagonal), so only Y is offset.
									.set(absoGuy, { x: 0, y: () => window.innerHeight * 0.65 }, 0)
									// Push these further outside the viewport so the fly-in feels more dramatic
									.set(
										absoTopLeft,
										{
											x: () => -window.innerWidth * 0.55,
											y: () => -window.innerHeight * 0.35,
										},
										0,
									)
									.set(
										absoTopRight,
										{
											x: () => window.innerWidth * 0.6,
											y: () => -window.innerHeight * 0.3,
										},
										0,
									)
									.set(
										absoBottomRight,
										{
											x: () => window.innerWidth * 0.55,
											y: () => window.innerHeight * 0.45,
										},
										0,
									)
									// Phase 1: reveal the first pill text AFTER the pin starts (as you scroll)
									.set(videoTextEl, { visibility: 'visible' }, '>0')
									.to(
										videoTextInners,
										{ yPercent: 0, duration: 0.55, ease: 'none', stagger: 0.1 },
										'>0',
									)
									// Phase 2: hold for a bit so it's readable
									.to({}, { duration: 0.9 })
									// Phase 3: sink each pill into its own "floor" (masked by overflow-hidden on .video-text-pill)
									.to(
										videoTextInners,
										{
											yPercent: 140,
											duration: 0.7,
											ease: 'none',
											stagger: 0.1,
										},
										'>0',
									)
									.set(videoTextEl, { visibility: 'hidden' })
									// Second phase: shrink the video container
									.to(
										openingVideoEl,
										{
											width: '48.958vw',
											height: '25.556vw',
											borderRadius: '21.944vw',
											// Lift up so its bottom ends ~10.833vw above the section bottom after scaling
											// (use px so it stays consistent, and invalidateOnRefresh recalculates on resize)
											y: () => -((window.innerWidth * 10.833) / 100),
											ease: 'none',
											transformOrigin: '50% 50%',
											duration: 1,
										},
										'>0',
									)
									// After scaling finishes, slide the globe up on top of the video
									// Only starts when you continue scrolling after the scale is done
									.set(globeEl, { visibility: 'visible' }, '>0')
									.to(globeEl, { y: 0, duration: 1, ease: 'none' }, '>0')
									// While globe is sliding up, reveal top/middle text (masked) + squiggly (fade+blur+up)
									.set(
										[
											absoTop,
											absoMiddle,
											absoSquiggly,
											absoGuy,
											absoTopLeft,
											absoTopRight,
											absoBottomRight,
										].filter(Boolean),
										{ visibility: 'visible' },
										'<0.35',
									)
									.to(
										absoTopLines,
										{
											yPercent: 0,
											duration: 0.65,
											ease: 'none',
											stagger: 0.08,
										},
										'<0.35',
									)
									.to(
										absoMiddleLines,
										{ yPercent: 0, duration: 0.65, ease: 'none' },
										'<0.42',
									)
									.to(
										absoSquiggly,
										{
											autoAlpha: 1,
											y: 0,
											filter: 'blur(0vw)',
											duration: 0.65,
											ease: 'none',
										},
										'<0.35',
									)
									// Images fly in: Top-left + Bottom-right together, then Guy + Top-right
									// Easing goal: fast acceleration -> slow brake (strong ease-out), with each image having its own feel.
									.to(
										absoTopLeft,
										{ x: 0, y: 0, duration: 0.9, ease: 'expo.out' },
										'<0.30',
									)
									.to(
										absoBottomRight,
										{ x: 0, y: 0, duration: 0.95, ease: 'power4.out' },
										'<0.30',
									)
									.to(
										absoGuy,
										{ x: 0, y: 0, duration: 1.05, ease: 'power4.out' },
										'<0.52',
									)
									.to(
										absoTopRight,
										{ x: 0, y: 0, duration: 1.0, ease: 'circ.out' },
										'<0.52',
									)
									// After globe, reveal the new 2-line pill text (masked up into view)
									.set(videoTextNextEl, { visibility: 'visible' }, '>0')
									.to(
										videoTextNextInners,
										{ yPercent: 0, duration: 0.7, ease: 'none', stagger: 0.1 },
										'>0',
									)
									// Swap to final H2 message
									.to(
										videoTextNextInners,
										{
											yPercent: 140,
											duration: 0.55,
											ease: 'none',
											stagger: 0.08,
										},
										'>0.4',
									)
									.set(videoTextNextEl, { visibility: 'hidden' })
									.set(videoTextFinalEl, { visibility: 'visible' })
									.to(
										videoTextFinalLines,
										{ yPercent: 0, duration: 0.8, ease: 'none', stagger: 0.1 },
										'>0',
									);
							}
						}
						/* ADDED BY AI END */

						if (window.gsap && gsap.ticker) {
							gsap.ticker.add((t) => lenis.raf(t * 1000));
							gsap.ticker.lagSmoothing(0);
						} else {
							const raf = (time) => {
								lenis.raf(time);
								requestAnimationFrame(raf);
							};
							requestAnimationFrame(raf);
						}
					}

					// Global cursor parallax for floating abso-content assets.
					// Important: apply transforms to inner <img> so ScrollTrigger can keep controlling the container position.
					function initAbsoHoverMicro() {
						if (!window.gsap) return;
						const finePointer =
							window.matchMedia && window.matchMedia('(pointer: fine)').matches;
						if (!finePointer) return;

						// Controls you can tweak (per element):
						// - x/y: strength multiplier (use negatives to invert direction)
						// - duration/ease: how "floaty" the follow feels
						const PARALLAX_BASE = { x: 23, y: 17 }; // px, global strength
						const PARALLAX = {
							'.abso-content #top-left': {
								x: 1.05,
								y: 1.0,
								duration: 0.55,
								ease: 'power3.out',
							},
							'.abso-content #bottom-right': {
								x: 1.1,
								y: 1.05,
								duration: 0.6,
								ease: 'power4.out',
							},
							'.abso-content #topright': {
								x: 0.9,
								y: 0.85,
								duration: 0.55,
								ease: 'circ.out',
							},
							'.abso-content #guy': {
								x: 0.75,
								y: 0.7,
								duration: 0.7,
								ease: 'power3.out',
							},
							'.abso-content .squiggly-gif-container': {
								x: 1.25,
								y: 1.15,
								duration: 0.5,
								ease: 'expo.out',
							},
						};

						const items = Object.entries(PARALLAX)
							.map(([selector, cfg]) => {
								const el = document.querySelector(selector);
								if (!el) return null;
								const target = el.querySelector('img') || el;
								target.style.willChange = 'transform';
								return {
									target,
									cfg,
									xTo: gsap.quickTo(target, 'x', {
										duration: cfg.duration,
										ease: cfg.ease,
									}),
									yTo: gsap.quickTo(target, 'y', {
										duration: cfg.duration,
										ease: cfg.ease,
									}),
								};
							})
							.filter(Boolean);

						const onMove = (e) => {
							const nx = (e.clientX / Math.max(1, window.innerWidth) - 0.5) * 2; // -1..1
							const ny =
								(e.clientY / Math.max(1, window.innerHeight) - 0.5) * 2; // -1..1
							items.forEach(({ xTo, yTo, cfg }) => {
								xTo(nx * PARALLAX_BASE.x * cfg.x);
								yTo(ny * PARALLAX_BASE.y * cfg.y);
							});
						};

						const reset = () => {
							items.forEach(({ xTo, yTo }) => {
								xTo(0);
								yTo(0);
							});
						};

						window.addEventListener('pointermove', onMove, { passive: true });
						window.addEventListener('pointerleave', reset);
						window.addEventListener('blur', reset);
					}

					// Non-preloader sections: inject immediately (no animation).
					injectNonPreloaderTripleLines();

					// Preloader section: inject + animate AFTER preloader completes.
					runPreloader().then(() => {
						injectPreloaderTripleLines();
						animatePreloaderTripleLines();
						initLenis();
						initInvitationScrollTrigger();
					});
					initAbsoHoverMicro();

					// Invitation animation: starts small/rotated, animates to full size on scroll
					function initInvitationScrollTrigger() {
						if (!window.gsap || !window.ScrollTrigger) return;

						const invitationEl = document.querySelector(
							'.revolver-parent .invitation',
						);
						const revolverParent = document.querySelector('.revolver-parent');
						const invitationText = document.querySelector(
							'.revolver-parent .invitation > p',
						);
						const afterWrapper = document.querySelector(
							'.revolver-parent .invitation .after-fullw-wrapper',
						);
						const afterCenter = afterWrapper?.querySelector('.center');
						const afterH4 = afterCenter?.querySelector('.h4');
						const afterH2 = afterCenter?.querySelector('.h2');
						const afterBtn = afterCenter?.querySelector('.custom-button');
						const afterGif = afterWrapper?.querySelector('img');

						if (!invitationEl || !revolverParent) return;

						// Set initial state (smaller, rotated, offset position)
						gsap.set(invitationEl, {
							width: '48.958vw',
							height: '26.042vw',
							rotation: 1.513,
							bottom: '-8vw',
							left: '27vw',
						});

						// Wrap text in mask for reveal effect (preserve CSS positioning on mask)
						if (invitationText) {
							const mask = document.createElement('span');
							mask.className = 'invitation-text-mask';
							mask.style.cssText =
								'position: absolute; top: 10.694vw; left: 21.361vw; display: block; overflow: hidden;';
							invitationText.parentNode.insertBefore(mask, invitationText);
							mask.appendChild(invitationText);
							// Reset p positioning and set up for mask animation
							gsap.set(invitationText, {
								position: 'relative',
								top: 'auto',
								left: 'auto',
								display: 'block',
								willChange: 'transform',
								yPercent: 100, // Start hidden below (at the floor)
							});
						}

						// Prepare after-fullw-wrapper content for reveal animation
						// H4: wrap in single mask (no line splitting)
						let afterH4Inner = null;
						if (afterH4) {
							const mask = document.createElement('span');
							mask.className = 'line-mask';
							mask.style.cssText = 'display: block; overflow: hidden;';
							const inner = document.createElement('span');
							inner.className = 'line';
							inner.style.cssText = 'display: block; will-change: transform;';
							inner.innerHTML = afterH4.innerHTML;
							afterH4.innerHTML = '';
							mask.appendChild(inner);
							afterH4.appendChild(mask);
							afterH4Inner = inner;
						}
						const afterH2Lines = afterH2 ? wrapBrSeparatedLinesToMasks(afterH2) : [];

						// Hide after-wrapper content initially
						gsap.set(afterWrapper, { visibility: 'hidden' });
						gsap.set([afterH4Inner, ...afterH2Lines].filter(Boolean), { yPercent: 120 });
						gsap.set(afterBtn, { autoAlpha: 0, y: 10 });
						gsap.set(afterGif, { autoAlpha: 0, y: 16, filter: 'blur(.694vw)' });

						// ScrollTrigger timeline: pin → reveal text → mask down → resize → reveal after content
						gsap
							.timeline({
								scrollTrigger: {
									trigger: revolverParent,
									start: 'bottom bottom',
									end: '+=500%', // longer pin for all phases including after content
									pin: true,
									pinSpacing: true,
									scrub: 1.5,
								},
							})
							// Phase 1: Reveal text (comes up from the floor)
							.to(
								invitationText,
								{
									yPercent: 0,
									duration: 0.8,
									ease: 'none',
								},
								0,
							)
							// Phase 2: Hold for readability
							.to({}, { duration: 0.6 })
							// Phase 3: Mask down (sinks to the floor)
							.to(invitationText, {
								yPercent: 100,
								duration: 0.8,
								ease: 'none',
							})
							// Hide text permanently after mask down
							.set(invitationText, { visibility: 'hidden' })
							// Phase 4: Resize invitation to full screen
							.to(invitationEl, {
								width: '100vw',
								height: '110vh',
								rotation: 0,
								bottom: 0,
								left: 0,
								duration: 1.2,
								ease: 'none',
							})
							// Phase 5: Reveal after-fullw-wrapper content (like revolver items)
							.set(afterWrapper, { visibility: 'visible' })
							// Reveal h4 (single line)
							.to(afterH4Inner, {
								yPercent: 0,
								duration: 0.65,
								ease: 'none',
							})
							// Reveal h2 lines
							.to(afterH2Lines, {
								yPercent: 0,
								duration: 0.75,
								ease: 'none',
								stagger: 0.08,
							}, '-=0.4')
							// Reveal button
							.to(afterBtn, {
								autoAlpha: 1,
								y: 0,
								duration: 0.55,
								ease: 'none',
							}, '-=0.3')
							// Reveal gif with blur/fade
							.to(afterGif, {
								autoAlpha: 1,
								y: 0,
								filter: 'blur(0vw)',
								duration: 0.7,
								ease: 'none',
							}, '-=0.5');
					}
					/* ADDED BY AI END */
				});
			})();

			// Mouse-follow image scatter effect for .clonable-prefooter
			(function () {
				const root = document.querySelector('.clonable-prefooter');
				if (!root) return;

				const images = [];
				root.querySelectorAll('.medias img').forEach((image) => {
					images.push(image.getAttribute('src'));
				});

				if (!images.length) return;

				// TUNE: lower number = fewer images spawned (less clutter)
				const IMAGES_PER_SCREEN = 3;

				let incr = 0,
					oldIncrX = 0,
					oldIncrY = 0,
					resetDist = window.innerWidth / IMAGES_PER_SCREEN,
					indexImg = 0;

				root.addEventListener(
					'mousemove',
					(e) => {
						oldIncrX = e.clientX;
						oldIncrY = e.clientY;
					},
					{ once: true },
				);

				root.addEventListener('mousemove', (e) => {
					const valX = e.clientX;
					const valY = e.clientY;

					incr += Math.abs(valX - oldIncrX) + Math.abs(valY - oldIncrY);

					if (incr > resetDist) {
						incr = 0;
						createMedia(
							valX,
							valY - root.getBoundingClientRect().top,
							valX - oldIncrX,
							valY - oldIncrY,
						);
					}

					oldIncrX = valX;
					oldIncrY = valY;
				});

				function createMedia(x, y, deltaX, deltaY) {
					if (!window.gsap) return;

					const image = document.createElement('img');
					image.setAttribute('src', images[indexImg]);
					root.appendChild(image);

					const tl = gsap.timeline({
						onComplete: () => {
							root.removeChild(image);
							tl && tl.kill();
						},
					});

					tl.fromTo(
						image,
						{
							xPercent: -50 + (Math.random() - 0.5) * 80,
							yPercent: -50 + (Math.random() - 0.5) * 10,
							scaleX: 1.3,
							scaleY: 1.3,
						},
						{
							scaleX: 1,
							scaleY: 1,
							ease: 'elastic.out(2, 0.6)',
							duration: 0.45,
						},
					);

					tl.fromTo(
						image,
						{
							x,
							y,
							rotation: (Math.random() - 0.5) * 20,
						},
						{
							x: '+=' + deltaX * 4,
							y: '+=' + deltaY * 4,
							rotation: (Math.random() - 0.5) * 20,
							ease: 'power4.out',
							duration: 1.05,
						},
						'<',
					);

					tl.to(image, {
						duration: 0.2,
						scale: 0.5,
						delay: 0.05,
						ease: 'back.in(1.5)',
					});

					indexImg = (indexImg + 1) % images.length;
				}
			})();

			// GIF animation for clonable-prefooter - plays once when section is visible
			// GIF src is set dynamically to trigger playback on scroll
			// GIF has loop count = 1, so it stops on last frame automatically
			(function () {
				const gifElement = document.getElementById('stand-together-gif');
				const section = document.querySelector('.clonable-prefooter');

				console.log('[GIF] Image element:', gifElement);
				console.log('[GIF] Section element:', section);

				if (!gifElement || !section) {
					console.error('[GIF] Image or section not found!');
					return;
				}

				let hasPlayed = false;

				// Use Intersection Observer - sets GIF src when section is visible
				const observer = new IntersectionObserver(
					(entries) => {
						entries.forEach((entry) => {
							console.log(
								'[GIF] IntersectionObserver triggered, isIntersecting:',
								entry.isIntersecting,
								'ratio:',
								entry.intersectionRatio,
							);

							if (entry.isIntersecting && !hasPlayed) {
								hasPlayed = true;
								console.log(
									'[GIF] Section is visible - loading and playing GIF',
								);
								// Setting src triggers the GIF to load and play from the start
								gifElement.src = './assets/Banner-ezgif.com-loop-count.gif';
								observer.disconnect();
							}
						});
					},
					{
						threshold: 0.3, // Trigger when 30% of section is visible
					},
				);

				observer.observe(section);
				console.log(
					'[GIF] IntersectionObserver set up for .clonable-prefooter',
				);
			})();
		</script>
	</body>
</html>
